From c7867932b6a6531143580f9eb8cb7d3d58bc52af Mon Sep 17 00:00:00 2001
From: Jiajian Wu <jair.wu@rock-chips.com>
Date: Wed, 23 Oct 2024 14:56:33 +0800
Subject: [PATCH] feat(drm): update drm display

Signed-off-by: Jiajian Wu <jair.wu@rock-chips.com>
---
 src/drivers/display/drm/lv_linux_drm.c | 1498 ++++++++++++++----------
 src/drivers/display/drm/lv_linux_drm.h |   23 +-
 2 files changed, 892 insertions(+), 629 deletions(-)

diff --git a/src/drivers/display/drm/lv_linux_drm.c b/src/drivers/display/drm/lv_linux_drm.c
index faa2212..3f8c598 100644
--- a/src/drivers/display/drm/lv_linux_drm.c
+++ b/src/drivers/display/drm/lv_linux_drm.c
@@ -7,829 +7,1085 @@
  *      INCLUDES
  *********************/
 #include "lv_linux_drm.h"
+
 #if LV_USE_LINUX_DRM
 
-#include <errno.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <time.h>
+#include <sys/time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <fcntl.h>
-#include <poll.h>
-#include <stdint.h>
-#include <sys/mman.h>
 #include <unistd.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include <inttypes.h>
+#include <poll.h>
+#include <malloc.h>
 
+#include <drm_fourcc.h>
+#include <drm_mode.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
-#include <drm_fourcc.h>
 
-/*********************
- *      DEFINES
- *********************/
-#if LV_COLOR_DEPTH == 32
-    #define DRM_FOURCC DRM_FORMAT_XRGB8888
-#elif LV_COLOR_DEPTH == 16
-    #define DRM_FOURCC DRM_FORMAT_RGB565
+#define NUM_DUMB_BO 3
+#define ALIGN(x, a)     (((x) + (a - 1)) & ~(a - 1))
+
+#if (LV_COLOR_DEPTH == 16)
+#define DRM_FORMAT      DRM_FORMAT_RGB565
+#define RGA_FORMAT      RK_FORMAT_BGR_565
+#elif (LV_COLOR_DEPTH == 24)
+#define DRM_FORMAT      DRM_FORMAT_RGB888
+#define RGA_FORMAT      RK_FORMAT_BGR_888
+#elif (LV_COLOR_DEPTH == 32)
+#define DRM_FORMAT      DRM_FORMAT_ARGB8888
+#define RGA_FORMAT      RK_FORMAT_BGRA_8888
 #else
-    #error LV_COLOR_DEPTH not supported
+    #error "Unsupported depth"
 #endif
 
-/**********************
- *      TYPEDEFS
- **********************/
-typedef struct {
-    uint32_t handle;
-    uint32_t pitch;
-    uint32_t offset;
-    unsigned long int size;
-    uint8_t * map;
-    uint32_t fb_handle;
-} drm_buffer_t;
-
-typedef struct {
+typedef struct drm_bo {
+    int fd;
+    void *ptr;
+    size_t size;
+    size_t offset;
+    size_t pitch;
+    unsigned int handle;
+    int fb_id;
+    int buf_fd;
+    int w;
+    int h;
+} drm_bo_t;
+
+typedef struct drm_device {
     int fd;
-    uint32_t conn_id, enc_id, crtc_id, plane_id, crtc_idx;
-    uint32_t width, height;
-    uint32_t mmWidth, mmHeight;
-    uint32_t fourcc;
-    drmModeModeInfo mode;
-    uint32_t blob_id;
-    drmModeCrtc * saved_crtc;
-    drmModeAtomicReq * req;
-    drmEventContext drm_event_ctx;
-    drmModePlane * plane;
-    drmModeCrtc * crtc;
-    drmModeConnector * conn;
-    uint32_t count_plane_props;
-    uint32_t count_crtc_props;
-    uint32_t count_conn_props;
-    drmModePropertyPtr plane_props[128];
-    drmModePropertyPtr crtc_props[128];
-    drmModePropertyPtr conn_props[128];
-    drm_buffer_t drm_bufs[2]; /*DUMB buffers*/
-} drm_dev_t;
-
-/**********************
- *  STATIC PROTOTYPES
- **********************/
-static uint32_t get_plane_property_id(drm_dev_t * drm_dev, const char * name);
-static uint32_t get_crtc_property_id(drm_dev_t * drm_dev, const char * name);
-static uint32_t get_conn_property_id(drm_dev_t * drm_dev, const char * name);
-static void page_flip_handler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec,
-                              void * user_data);
-static int drm_get_plane_props(drm_dev_t * drm_dev);
-static int drm_get_crtc_props(drm_dev_t * drm_dev);
-static int drm_get_conn_props(drm_dev_t * drm_dev);
-static int drm_add_plane_property(drm_dev_t * drm_dev, const char * name, uint64_t value);
-static int drm_add_crtc_property(drm_dev_t * drm_dev, const char * name, uint64_t value);
-static int drm_add_conn_property(drm_dev_t * drm_dev, const char * name, uint64_t value);
-static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf);
-static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane_id, uint32_t crtc_id,
-                      uint32_t crtc_idx);
-static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id);
-static int drm_open(const char * path);
-static int drm_setup(drm_dev_t * drm_dev, const char * device_path, int64_t connector_id, unsigned int fourcc);
-static int drm_allocate_dumb(drm_dev_t * drm_dev, drm_buffer_t * buf);
-static int drm_setup_buffers(drm_dev_t * drm_dev);
-static void drm_flush_wait(lv_display_t * drm_dev);
-static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map);
-
-/**********************
- *  STATIC VARIABLES
- **********************/
-
-/**********************
- *      MACROS
- **********************/
-#ifndef DIV_ROUND_UP
-    #define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
-#endif
-
-/**********************
- *   GLOBAL FUNCTIONS
- **********************/
-
-lv_display_t * lv_linux_drm_create(void)
-{
-    drm_dev_t * drm_dev = lv_malloc_zeroed(sizeof(drm_dev_t));
-    LV_ASSERT_MALLOC(drm_dev);
-    if(drm_dev == NULL) return NULL;
-
-    lv_display_t * disp = lv_display_create(800, 480);
-    if(disp == NULL) {
-        lv_free(drm_dev);
-        return NULL;
-    }
-    drm_dev->fd = -1;
-    lv_display_set_driver_data(disp, drm_dev);
-    lv_display_set_flush_wait_cb(disp, drm_flush_wait);
-    lv_display_set_flush_cb(disp, drm_flush);
 
-    return disp;
-}
+    struct {
+        int width;
+        int height;
+
+        int hdisplay;
+        int vdisplay;
+    } mode;
+
+    drmModeResPtr res;
+
+    int connector_id;
+    int encoder_id;
+    int crtc_id;
+    int plane_id;
+    int last_fb_id;
+	uint32_t *con_ids;
+	unsigned int num_cons;
+	drmModeModeInfo mode_info;
+
+    int waiting_for_flip;
+    struct pollfd drm_pollfd;
+    drmEventContext drm_evctx;
+
+    int lcd_sw;
+    char * drm_buff;
+    lv_color_t * disp_buf;
+    int disp_rot;
+
+    int quit;
+    pthread_t pid;
+    pthread_mutex_t mutex;
+    int draw_update;
+
+    drm_bo_t *vop_buf[2];
+#if LV_DRM_USE_RGA
+    drm_bo_t *gbo;
+#endif
+} drm_device_t;
 
-void lv_linux_drm_set_file(lv_display_t * disp, const char * file, int64_t connector_id)
+static int bo_map(drm_device_t *dev, drm_bo_t *bo)
 {
-    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    struct drm_mode_map_dumb arg = {
+        .handle = bo->handle,
+    };
+    struct drm_prime_handle fd_args = {
+        .fd = -1,
+        .handle = bo->handle,
+        .flags = 0,
+    };
     int ret;
 
-    ret = drm_setup(drm_dev, file, connector_id, DRM_FOURCC);
-    if(ret) {
-        close(drm_dev->fd);
-        drm_dev->fd = -1;
-        return;
-    }
+    ret = drmIoctl(dev->fd, DRM_IOCTL_MODE_MAP_DUMB, &arg);
+    if (ret)
+        return ret;
 
-    ret = drm_setup_buffers(drm_dev);
-    if(ret) {
-        LV_LOG_ERROR("DRM buffer allocation failed");
-        close(drm_dev->fd);
-        drm_dev->fd = -1;
-        return;
+    ret = drmIoctl(dev->fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &fd_args);
+    if (ret)
+    {
+        LV_LOG_ERROR("handle_to_fd failed ret=%d, handle=%x", ret ,fd_args.handle);
+        return -1;
     }
+    bo->buf_fd = fd_args.fd;
 
-    LV_LOG_INFO("DRM subsystem and buffer mapped successfully");
-
-    int32_t hor_res = drm_dev->width;
-    int32_t ver_res = drm_dev->height;
-    int32_t width = drm_dev->mmWidth;
-
-    size_t buf_size = LV_MIN(drm_dev->drm_bufs[1].size, drm_dev->drm_bufs[0].size);
-    lv_display_set_buffers(disp, drm_dev->drm_bufs[1].map, drm_dev->drm_bufs[0].map, buf_size,
-                           LV_DISPLAY_RENDER_MODE_DIRECT);
-    lv_display_set_resolution(disp, hor_res, ver_res);
-
-    if(width) {
-        lv_display_set_dpi(disp, DIV_ROUND_UP(hor_res * 25400, width * 1000));
+    bo->ptr = mmap(0, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                   dev->fd, arg.offset);
+    if (bo->ptr == MAP_FAILED) {
+        bo->ptr = NULL;
+        return -1;
     }
 
-    LV_LOG_INFO("Resolution is set to %" LV_PRId32 "x%" LV_PRId32 " at %" LV_PRId32 "dpi",
-                hor_res, ver_res, lv_display_get_dpi(disp));
+    return 0;
 }
 
-/**********************
- *   STATIC FUNCTIONS
- **********************/
-
-static uint32_t get_plane_property_id(drm_dev_t * drm_dev, const char * name)
+static void bo_unmap(drm_device_t *dev, drm_bo_t *bo)
 {
-    uint32_t i;
-
-    LV_LOG_TRACE("Find plane property: %s", name);
-
-    for(i = 0; i < drm_dev->count_plane_props; ++i)
-        if(!lv_strcmp(drm_dev->plane_props[i]->name, name))
-            return drm_dev->plane_props[i]->prop_id;
-
-    LV_LOG_TRACE("Unknown plane property: %s", name);
+    if (dev == NULL)
+        return;
+    if (!bo->ptr)
+        return;
 
-    return 0;
+    drmUnmap(bo->ptr, bo->size);
+    if (bo->buf_fd > 0)
+        close(bo->buf_fd);
+    bo->ptr = NULL;
 }
 
-static uint32_t get_crtc_property_id(drm_dev_t * drm_dev, const char * name)
+void bo_destroy(drm_device_t *dev, drm_bo_t *bo)
 {
-    uint32_t i;
+    struct drm_mode_destroy_dumb arg = {
+        .handle = bo->handle,
+    };
 
-    LV_LOG_TRACE("Find crtc property: %s", name);
+    if (bo->fb_id)
+        drmModeRmFB(dev->fd, bo->fb_id);
 
-    for(i = 0; i < drm_dev->count_crtc_props; ++i)
-        if(!lv_strcmp(drm_dev->crtc_props[i]->name, name))
-            return drm_dev->crtc_props[i]->prop_id;
+    bo_unmap(dev, bo);
 
-    LV_LOG_TRACE("Unknown crtc property: %s", name);
+    if (bo->handle)
+        drmIoctl(dev->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
 
-    return 0;
+    free(bo);
 }
 
-static uint32_t get_conn_property_id(drm_dev_t * drm_dev, const char * name)
+static drm_bo_t *
+bo_create(drm_device_t *dev, int width, int height, int format)
 {
-    uint32_t i;
-
-    LV_LOG_TRACE("Find conn property: %s", name);
+    struct drm_mode_create_dumb arg = {
+        .bpp = LV_COLOR_DEPTH,
+        .width = ALIGN(width, 16),
+        .height = ALIGN(height, 16),
+    };
+    drm_bo_t *bo;
+    uint32_t handles[4] = {0}, pitches[4] = {0}, offsets[4] = {0};
+    int ret;
 
-    for(i = 0; i < drm_dev->count_conn_props; ++i)
-        if(!lv_strcmp(drm_dev->conn_props[i]->name, name))
-            return drm_dev->conn_props[i]->prop_id;
+    bo = malloc(sizeof(drm_bo_t));
+    if (bo == NULL) {
+        LV_LOG_ERROR("allocate bo failed");
+        return NULL;
+    }
+    memset(bo, 0, sizeof(*bo));
+    if (format == DRM_FORMAT_NV12) {
+        arg.bpp = 8;
+        arg.height = height * 3 / 2;
+    }
 
-    LV_LOG_TRACE("Unknown conn property: %s", name);
+    ret = drmIoctl(dev->fd, DRM_IOCTL_MODE_CREATE_DUMB, &arg);
+    if (ret) {
+        LV_LOG_ERROR("create dumb failed");
+        goto err;
+    }
 
-    return 0;
-}
+    bo->fd = dev->fd;
+    bo->handle = arg.handle;
+    bo->size = arg.size;
+    bo->pitch = arg.pitch;
+    bo->w = width;
+    bo->h = height;
 
-static void page_flip_handler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec,
-                              void * user_data)
-{
-    LV_UNUSED(fd);
-    LV_UNUSED(sequence);
-    LV_UNUSED(tv_sec);
-    LV_UNUSED(tv_usec);
-    LV_LOG_TRACE("flip");
-    drm_dev_t * drm_dev = user_data;
-    if(drm_dev->req) {
-        drmModeAtomicFree(drm_dev->req);
-        drm_dev->req = NULL;
+    ret = bo_map(dev, bo);
+    if (ret) {
+        LV_LOG_ERROR("map bo failed");
+        goto err;
     }
-}
-
-static int drm_get_plane_props(drm_dev_t * drm_dev)
-{
-    uint32_t i;
 
-    drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(drm_dev->fd, drm_dev->plane_id,
-                                                                  DRM_MODE_OBJECT_PLANE);
-    if(!props) {
-        LV_LOG_ERROR("drmModeObjectGetProperties failed");
-        return -1;
+    switch (format) {
+    case DRM_FORMAT_NV12:
+    case DRM_FORMAT_NV16:
+      handles[0] = bo->handle;
+      pitches[0] = bo->pitch ;
+      offsets[0] = 0;
+      handles[1] = bo->handle;
+      pitches[1] = pitches[0];
+      offsets[1] = pitches[0] * height;
+      break;
+    case DRM_FORMAT_RGB332:
+      handles[0] = bo->handle;
+      pitches[0] = bo->pitch;
+      offsets[0] = 0;
+      break;
+    case DRM_FORMAT_RGB565:
+    case DRM_FORMAT_BGR565:
+      handles[0] = bo->handle;
+      pitches[0] = bo->pitch ;
+      offsets[0] = 0;
+      break;
+    case DRM_FORMAT_RGB888:
+    case DRM_FORMAT_BGR888:
+      handles[0] = bo->handle;
+      pitches[0] = bo->pitch ;
+      offsets[0] = 0;
+      break;
+    case DRM_FORMAT_ARGB8888:
+    case DRM_FORMAT_ABGR8888:
+    case DRM_FORMAT_RGBA8888:
+    case DRM_FORMAT_BGRA8888:
+      handles[0] = bo->handle;
+      pitches[0] = bo->pitch ;
+      offsets[0] = 0;
+      break;
     }
-    LV_LOG_TRACE("Found %u plane props", props->count_props);
-    drm_dev->count_plane_props = props->count_props;
-    for(i = 0; i < props->count_props; i++) {
-        drm_dev->plane_props[i] = drmModeGetProperty(drm_dev->fd, props->props[i]);
-        LV_LOG_TRACE("Added plane prop %u:%s", drm_dev->plane_props[i]->prop_id, drm_dev->plane_props[i]->name);
+
+    ret = drmModeAddFB2(dev->fd, width, height, format, handles,
+                        pitches, offsets, (uint32_t *)&bo->fb_id, 0);
+    if (ret) {
+        LV_LOG_ERROR("add fb failed");
+        goto err;
     }
-    drmModeFreeObjectProperties(props);
+    LV_LOG_USER("Created bo: %d, %dx%d", bo->fb_id, width, height);
 
-    return 0;
+    return bo;
+err:
+    bo_destroy(dev, bo);
+    return NULL;
 }
 
-static int drm_get_crtc_props(drm_dev_t * drm_dev)
+drm_bo_t *malloc_drm_bo(drm_device_t *dev, int width, int height, int format)
 {
-    uint32_t i;
-
-    drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(drm_dev->fd, drm_dev->crtc_id,
-                                                                  DRM_MODE_OBJECT_CRTC);
-    if(!props) {
-        LV_LOG_ERROR("drmModeObjectGetProperties failed");
-        return -1;
-    }
-    LV_LOG_TRACE("Found %u crtc props", props->count_props);
-    drm_dev->count_crtc_props = props->count_props;
-    for(i = 0; i < props->count_props; i++) {
-        drm_dev->crtc_props[i] = drmModeGetProperty(drm_dev->fd, props->props[i]);
-        LV_LOG_TRACE("Added crtc prop %u:%s", drm_dev->crtc_props[i]->prop_id, drm_dev->crtc_props[i]->name);
-    }
-    drmModeFreeObjectProperties(props);
-
-    return 0;
+    return bo_create(dev, width, height, format);
 }
 
-static int drm_get_conn_props(drm_dev_t * drm_dev)
+void free_drm_bo(drm_device_t *dev, drm_bo_t *bo)
 {
-    uint32_t i;
-
-    drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(drm_dev->fd, drm_dev->conn_id,
-                                                                  DRM_MODE_OBJECT_CONNECTOR);
-    if(!props) {
-        LV_LOG_ERROR("drmModeObjectGetProperties failed");
-        return -1;
-    }
-    LV_LOG_TRACE("Found %u connector props", props->count_props);
-    drm_dev->count_conn_props = props->count_props;
-    for(i = 0; i < props->count_props; i++) {
-        drm_dev->conn_props[i] = drmModeGetProperty(drm_dev->fd, props->props[i]);
-        LV_LOG_TRACE("Added connector prop %u:%s", drm_dev->conn_props[i]->prop_id, drm_dev->conn_props[i]->name);
-    }
-    drmModeFreeObjectProperties(props);
-
-    return 0;
+    if (bo)
+        bo_destroy(dev, bo);
 }
 
-static int drm_add_plane_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
+static int drm_get_preferred_connector(void)
 {
-    int ret;
-    uint32_t prop_id = get_plane_property_id(drm_dev, name);
+    const char *path;
+    char buf[256] = "\0";
+    int fd;
 
-    if(!prop_id) {
-        LV_LOG_ERROR("Couldn't find plane prop %s", name);
-        return -1;
-    }
+#define DRM_CONNECTOR_CFG_PATH_ENV	"DRM_CONNECTOR_CFG_PATH"
+#define DRM_CONNECTOR_CFG_PATH_DEFAULT	"/tmp/drm_connector.cfg"
+    path = getenv(DRM_CONNECTOR_CFG_PATH_ENV);
+    if (!path)
+        path = DRM_CONNECTOR_CFG_PATH_DEFAULT;
 
-    ret = drmModeAtomicAddProperty(drm_dev->req, drm_dev->plane_id, get_plane_property_id(drm_dev, name), value);
-    if(ret < 0) {
-        LV_LOG_ERROR("drmModeAtomicAddProperty (%s:%" PRIu64 ") failed: %d", name, value, ret);
-        return ret;
+    fd = open(path, O_RDONLY);
+    if (read(fd, buf, sizeof(buf)) != sizeof(buf)) {
+        LV_LOG_TRACE("read failed, use default connector");
     }
+    close(fd);
 
-    return 0;
-}
-
-static int drm_add_crtc_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
-{
-    int ret;
-    uint32_t prop_id = get_crtc_property_id(drm_dev, name);
-
-    if(!prop_id) {
-        LV_LOG_ERROR("Couldn't find crtc prop %s", name);
+    if (!buf[0])
         return -1;
-    }
-
-    ret = drmModeAtomicAddProperty(drm_dev->req, drm_dev->crtc_id, get_crtc_property_id(drm_dev, name), value);
-    if(ret < 0) {
-        LV_LOG_ERROR("drmModeAtomicAddProperty (%s:%" PRIu64 ") failed: %d", name, value, ret);
-        return ret;
-    }
 
-    return 0;
+    return atoi(buf);
 }
 
-static int drm_add_conn_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
+static int drm_get_preferred_mode(int *width, int *height)
 {
-    int ret;
-    uint32_t prop_id = get_conn_property_id(drm_dev, name);
+    const char *path;
+    char buf[256] = "\0";
+    int fd, w, h;
+
+#define DRM_MODE_CFG_PATH_ENV	"DRM_CONNECTOR_CFG_PATH"
+#define DRM_MODE_CFG_PATH_DEFAULT	"/tmp/drm_mode.cfg"
+    path = getenv(DRM_MODE_CFG_PATH_ENV);
+    if (!path)
+        path = DRM_MODE_CFG_PATH_DEFAULT;
+
+    fd = open(path, O_RDONLY);
+    if (read(fd, buf, sizeof(buf)) != sizeof(buf)) {
+        LV_LOG_TRACE("read failed, use default mode");
+    }
+    close(fd);
 
-    if(!prop_id) {
-        LV_LOG_ERROR("Couldn't find conn prop %s", name);
+    if (!buf[0])
         return -1;
-    }
 
-    ret = drmModeAtomicAddProperty(drm_dev->req, drm_dev->conn_id, get_conn_property_id(drm_dev, name), value);
-    if(ret < 0) {
-        LV_LOG_ERROR("drmModeAtomicAddProperty (%s:%" PRIu64 ") failed: %d", name, value, ret);
-        return ret;
-    }
+    if (2 != sscanf(buf, "%dx%d", &w, &h))
+        return -1;
+
+    *width = w;
+    *height = h;
 
     return 0;
 }
 
-static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
+static drmModeConnectorPtr
+drm_get_connector(drm_device_t *dev, int connector_id)
 {
-    int ret;
-    static int first = 1;
-    uint32_t flags = DRM_MODE_PAGE_FLIP_EVENT | DRM_MODE_ATOMIC_NONBLOCK;
+    drmModeConnectorPtr conn;
 
-    drm_dev->req = drmModeAtomicAlloc();
+    conn = drmModeGetConnector(dev->fd, connector_id);
+    if (!conn)
+        return NULL;
 
-    /* On first Atomic commit, do a modeset */
-    if(first) {
-        drm_add_conn_property(drm_dev, "CRTC_ID", drm_dev->crtc_id);
+    LV_LOG_TRACE("Connector id: %d, %sconnected, modes: %d", connector_id,
+              (conn->connection == DRM_MODE_CONNECTED) ? "" : "dis",
+              conn->count_modes);
+    if (conn->connection == DRM_MODE_CONNECTED && conn->count_modes)
+        return conn;
 
-        drm_add_crtc_property(drm_dev, "MODE_ID", drm_dev->blob_id);
-        drm_add_crtc_property(drm_dev, "ACTIVE", 1);
+    drmModeFreeConnector(conn);
+    return NULL;
+}
 
-        flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
+static drmModeConnectorPtr
+drm_find_best_connector(drm_device_t *dev)
+{
+    drmModeResPtr res = dev->res;
+    drmModeConnectorPtr conn;
+    int i, preferred_connector_id = drm_get_preferred_connector();
+
+    LV_LOG_TRACE("Preferred connector id: %d", preferred_connector_id);
+    conn = drm_get_connector(dev, preferred_connector_id);
+    if (conn)
+        return conn;
+
+    dev->num_cons = 1;
+	dev->con_ids = calloc(1, sizeof(*dev->con_ids));
+    for (i = 0; i < res->count_connectors; i++) {
+        conn = drm_get_connector(dev, res->connectors[i]);
+        if (conn) {
+            dev->con_ids[0] = conn->connector_id;
+            memcpy(&dev->mode_info, &conn->modes[0], sizeof(dev->mode_info));
+            return conn;
+        }
+    }
+    return NULL;
+}
 
-        first = 0;
+static drmModeCrtcPtr
+drm_find_best_crtc(drm_device_t *dev, drmModeConnectorPtr conn)
+{
+    drmModeResPtr res = dev->res;
+    drmModeEncoderPtr encoder;
+    drmModeCrtcPtr crtc;
+    int i, preferred_crtc_id = 0;
+    int crtcs_for_connector = 0;
+
+    encoder = drmModeGetEncoder(dev->fd, conn->encoder_id);
+    if (encoder) {
+        preferred_crtc_id = encoder->crtc_id;
+        drmModeFreeEncoder(encoder);
+        LV_LOG_TRACE("Preferred crtc: %d", preferred_crtc_id);
     }
 
-    drm_add_plane_property(drm_dev, "FB_ID", buf->fb_handle);
-    drm_add_plane_property(drm_dev, "CRTC_ID", drm_dev->crtc_id);
-    drm_add_plane_property(drm_dev, "SRC_X", 0);
-    drm_add_plane_property(drm_dev, "SRC_Y", 0);
-    drm_add_plane_property(drm_dev, "SRC_W", drm_dev->width << 16);
-    drm_add_plane_property(drm_dev, "SRC_H", drm_dev->height << 16);
-    drm_add_plane_property(drm_dev, "CRTC_X", 0);
-    drm_add_plane_property(drm_dev, "CRTC_Y", 0);
-    drm_add_plane_property(drm_dev, "CRTC_W", drm_dev->width);
-    drm_add_plane_property(drm_dev, "CRTC_H", drm_dev->height);
+    crtc = drmModeGetCrtc(dev->fd, preferred_crtc_id);
+    if (crtc)
+        return crtc;
 
-    ret = drmModeAtomicCommit(drm_dev->fd, drm_dev->req, flags, drm_dev);
-    if(ret) {
-        LV_LOG_ERROR("drmModeAtomicCommit failed: %s (%d)", strerror(errno), errno);
-        drmModeAtomicFree(drm_dev->req);
-        return ret;
+    for (i = 0; i < res->count_encoders; i++) {
+        encoder = drmModeGetEncoder(dev->fd, res->encoders[i]);
+        if (encoder)
+            crtcs_for_connector |= encoder->possible_crtcs;
+        drmModeFreeEncoder(encoder);
     }
+    LV_LOG_TRACE("Possible crtcs: %x", crtcs_for_connector);
+    if (!crtcs_for_connector)
+        return NULL;
 
-    return 0;
+    return drmModeGetCrtc(dev->fd, res->crtcs[ffs(crtcs_for_connector) - 1]);
 }
 
-static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane_id, uint32_t crtc_id,
-                      uint32_t crtc_idx)
+int
+drm_plane_is_primary(drm_device_t *dev, int plane_id)
 {
-    LV_UNUSED(crtc_id);
-    drmModePlaneResPtr planes;
-    drmModePlanePtr plane;
+    drmModeObjectPropertiesPtr props;
+    drmModePropertyPtr prop;
     unsigned int i;
-    unsigned int j;
-    int ret = 0;
-    unsigned int format = fourcc;
-
-    planes = drmModeGetPlaneResources(drm_dev->fd);
-    if(!planes) {
-        LV_LOG_ERROR("drmModeGetPlaneResources failed");
-        return -1;
+    int type = 0;
+
+    props = drmModeObjectGetProperties(dev->fd, plane_id,
+                                       DRM_MODE_OBJECT_PLANE);
+    if (!props)
+        return 0;
+
+    for (i = 0; i < props->count_props; i++) {
+        prop = drmModeGetProperty(dev->fd, props->props[i]);
+        if (prop && !strcmp(prop->name, "type"))
+            type = props->prop_values[i];
+        drmModeFreeProperty(prop);
     }
+    LV_LOG_TRACE("Plane: %d, type: %d", plane_id, type);
 
-    LV_LOG_TRACE("drm: found planes %u", planes->count_planes);
-
-    for(i = 0; i < planes->count_planes; ++i) {
-        plane = drmModeGetPlane(drm_dev->fd, planes->planes[i]);
-        if(!plane) {
-            LV_LOG_ERROR("drmModeGetPlane failed: %s", strerror(errno));
-            break;
-        }
-
-        if(!(plane->possible_crtcs & (1 << crtc_idx))) {
-            drmModeFreePlane(plane);
-            continue;
-        }
-
-        for(j = 0; j < plane->count_formats; ++j) {
-            if(plane->formats[j] == format)
-                break;
-        }
-
-        if(j == plane->count_formats) {
-            drmModeFreePlane(plane);
-            continue;
-        }
-
-        *plane_id = plane->plane_id;
-        drmModeFreePlane(plane);
-
-        LV_LOG_TRACE("found plane %d", *plane_id);
+    drmModeFreeObjectProperties(props);
+    return type == DRM_PLANE_TYPE_PRIMARY;
+}
 
-        break;
+int
+drm_plane_is_overlay(drm_device_t *dev, int plane_id)
+{
+    drmModeObjectPropertiesPtr props;
+    drmModePropertyPtr prop;
+    unsigned int i;
+    int type = 0;
+
+    props = drmModeObjectGetProperties(dev->fd, plane_id,
+                                       DRM_MODE_OBJECT_PLANE);
+    if (!props)
+        return 0;
+
+    for (i = 0; i < props->count_props; i++) {
+        prop = drmModeGetProperty(dev->fd, props->props[i]);
+        if (prop && !strcmp(prop->name, "type"))
+            type = props->prop_values[i];
+        drmModeFreeProperty(prop);
     }
+    LV_LOG_TRACE("Plane: %d, type: %d", plane_id, type);
 
-    if(i == planes->count_planes)
-        ret = -1;
-
-    drmModeFreePlaneResources(planes);
-
-    return ret;
+    drmModeFreeObjectProperties(props);
+    return type == DRM_PLANE_TYPE_OVERLAY;
 }
 
-static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
+int
+drm_plane_is_cursor(drm_device_t *dev, int plane_id)
 {
-    drmModeConnector * conn = NULL;
-    drmModeEncoder * enc = NULL;
-    drmModeRes * res;
-    int i;
-
-    if((res = drmModeGetResources(drm_dev->fd)) == NULL) {
-        LV_LOG_ERROR("drmModeGetResources() failed");
-        return -1;
+    drmModeObjectPropertiesPtr props;
+    drmModePropertyPtr prop;
+    unsigned int i;
+    int type = 0;
+
+    props = drmModeObjectGetProperties(dev->fd, plane_id,
+                                       DRM_MODE_OBJECT_PLANE);
+    if (!props)
+        return 0;
+
+    for (i = 0; i < props->count_props; i++) {
+        prop = drmModeGetProperty(dev->fd, props->props[i]);
+        if (prop && !strcmp(prop->name, "type"))
+            type = props->prop_values[i];
+        drmModeFreeProperty(prop);
     }
+    LV_LOG_TRACE("Plane: %d, type: %d", plane_id, type);
 
-    if(res->count_crtcs <= 0) {
-        LV_LOG_ERROR("no Crtcs");
-        goto free_res;
-    }
+    drmModeFreeObjectProperties(props);
+    return type == DRM_PLANE_TYPE_CURSOR;
+}
 
-    /* find all available connectors */
-    for(i = 0; i < res->count_connectors; i++) {
-        conn = drmModeGetConnector(drm_dev->fd, res->connectors[i]);
-        if(!conn)
-            continue;
+static drmModePlanePtr
+drm_get_plane(drm_device_t *dev, int plane_id, int pipe)
+{
+    drmModePlanePtr plane;
+    char* set_plane;
+    plane = drmModeGetPlane(dev->fd, plane_id);
+    if (!plane)
+        return NULL;
 
-        if(connector_id >= 0 && conn->connector_id != connector_id) {
-            drmModeFreeConnector(conn);
-            continue;
+    LV_LOG_TRACE("Check plane: %d, possible_crtcs: %x", plane_id,
+                 plane->possible_crtcs);
+    set_plane = getenv("LV_DRIVERS_SET_PLANE");
+    if (set_plane == NULL) {
+        LV_LOG_USER("LV_DRIVERS_SET_PLANE not be set, use DRM_PLANE_TYPE_PRIMARY");
+        if (drm_plane_is_primary(dev, plane_id)) {
+            if (plane->possible_crtcs & (1 << pipe))
+                return plane;
         }
-
-        if(conn->connection == DRM_MODE_CONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: connected", conn->connector_id);
+        goto end;
+    }
+    if (!strcmp("OVERLAY", set_plane)) {
+        LV_LOG_USER("LV_DRIVERS_SET_PLANE = DRM_PLANE_TYPE_OVERLAY");
+        if (drm_plane_is_overlay(dev, plane_id)) {
+            if (plane->possible_crtcs & (1 << pipe))
+                return plane;
         }
-        else if(conn->connection == DRM_MODE_DISCONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: disconnected", conn->connector_id);
+    } else if (!strcmp("PRIMARY", set_plane)) {
+        LV_LOG_USER("LV_DRIVERS_SET_PLANE = DRM_PLANE_TYPE_PRIMARY");
+        if (drm_plane_is_primary(dev, plane_id)) {
+            if (plane->possible_crtcs & (1 << pipe))
+                return plane;
         }
-        else if(conn->connection == DRM_MODE_UNKNOWNCONNECTION) {
-            LV_LOG_TRACE("drm: connector %d: unknownconnection", conn->connector_id);
+    } else if (!strcmp("CURSOR", set_plane)) {
+        LV_LOG_USER("LV_DRIVERS_SET_PLANE = DRM_PLANE_TYPE_CURSOR");
+        if (drm_plane_is_cursor(dev, plane_id)) {
+            if (plane->possible_crtcs & (1 << pipe))
+                return plane;
         }
-        else {
-            LV_LOG_TRACE("drm: connector %d: unknown", conn->connector_id);
+    } else {
+        LV_LOG_USER("LV_DRIVERS_SET_PLANE set err, use DRM_PLANE_TYPE_PRIMARY");
+        if (drm_plane_is_primary(dev, plane_id)) {
+            if (plane->possible_crtcs & (1 << pipe))
+                return plane;
         }
-
-        if(conn->connection == DRM_MODE_CONNECTED && conn->count_modes > 0)
-            break;
-
-        drmModeFreeConnector(conn);
-        conn = NULL;
-    };
-
-    if(!conn) {
-        LV_LOG_ERROR("suitable connector not found");
-        goto free_res;
     }
 
-    drm_dev->conn_id = conn->connector_id;
-    LV_LOG_TRACE("conn_id: %d", drm_dev->conn_id);
-    drm_dev->mmWidth = conn->mmWidth;
-    drm_dev->mmHeight = conn->mmHeight;
+end:
+    drmModeFreePlane(plane);
+    return NULL;
+}
 
-    lv_memcpy(&drm_dev->mode, &conn->modes[0], sizeof(drmModeModeInfo));
+static drmModePlanePtr
+drm_find_best_plane(drm_device_t *dev, drmModeCrtcPtr crtc)
+{
+    drmModeResPtr res = dev->res;
+    drmModePlaneResPtr pres;
+    drmModePlanePtr plane;
+    unsigned int i;
+    int pipe;
 
-    if(drmModeCreatePropertyBlob(drm_dev->fd, &drm_dev->mode, sizeof(drm_dev->mode),
-                                 &drm_dev->blob_id)) {
-        LV_LOG_ERROR("error creating mode blob");
-        goto free_res;
+    for (pipe = 0; pipe < res->count_crtcs; pipe++) {
+        if (crtc->crtc_id == res->crtcs[pipe])
+            break;
     }
+    if (pipe == res->count_crtcs)
+        return NULL;
 
-    drm_dev->width = conn->modes[0].hdisplay;
-    drm_dev->height = conn->modes[0].vdisplay;
+    pres = drmModeGetPlaneResources(dev->fd);
+    if (!pres)
+        return NULL;
 
-    for(i = 0 ; i < res->count_encoders; i++) {
-        enc = drmModeGetEncoder(drm_dev->fd, res->encoders[i]);
-        if(!enc)
-            continue;
+    for (i = 0; i < pres->count_planes; i++) {
+        plane = drm_get_plane(dev, pres->planes[i], pipe);
+        if (plane) {
+            drmModeFreePlaneResources(pres);
+            return plane;
+        }
+        drmModeFreePlane(plane);
+    }
 
-        LV_LOG_TRACE("enc%d enc_id %d conn enc_id %d", i, enc->encoder_id, conn->encoder_id);
+    drmModeFreePlaneResources(pres);
+    return NULL;
+}
 
-        if(enc->encoder_id == conn->encoder_id)
+static drmModeModeInfoPtr
+drm_find_best_mode(drm_device_t *dev, drmModeConnectorPtr conn)
+{
+    drmModeModeInfoPtr mode;
+    int i, preferred_width = 1920, preferred_height = 1080;
+
+    if (dev == NULL)
+        return 0;
+    drm_get_preferred_mode(&preferred_width, &preferred_height);
+    LV_LOG_TRACE("Preferred mode: %dx%d", preferred_width, preferred_height);
+
+    mode = &conn->modes[0];
+    for (i = 0; i < conn->count_modes; i++) {
+        LV_LOG_TRACE("Check mode: %dx%d",
+                conn->modes[i].hdisplay, conn->modes[i].vdisplay);
+        if (conn->modes[i].hdisplay == preferred_width &&
+                conn->modes[i].vdisplay == preferred_height) {
+            mode = &conn->modes[i];
             break;
-
-        drmModeFreeEncoder(enc);
-        enc = NULL;
+        }
     }
 
-    if(enc) {
-        drm_dev->enc_id = enc->encoder_id;
-        LV_LOG_TRACE("enc_id: %d", drm_dev->enc_id);
-        drm_dev->crtc_id = enc->crtc_id;
-        LV_LOG_TRACE("crtc_id: %d", drm_dev->crtc_id);
-        drmModeFreeEncoder(enc);
-    }
-    else {
-        /* Encoder hasn't been associated yet, look it up */
-        for(i = 0; i < conn->count_encoders; i++) {
-            int crtc, crtc_id = -1;
+    return mode;
+}
 
-            enc = drmModeGetEncoder(drm_dev->fd, conn->encoders[i]);
-            if(!enc)
-                continue;
+static int drm_get_preferred_fb_mode(int *width, int *height)
+{
+    char *buf;
+    int w, h;
 
-            for(crtc = 0 ; crtc < res->count_crtcs; crtc++) {
-                uint32_t crtc_mask = 1 << crtc;
+    buf = getenv("LVGL_DRM_FB_MODE");
+    if (!buf)
+        return -1;
 
-                crtc_id = res->crtcs[crtc];
+    if (2 != sscanf(buf, "%dx%d", &w, &h))
+        return -1;
 
-                LV_LOG_TRACE("enc_id %d crtc%d id %d mask %x possible %x", enc->encoder_id, crtc, crtc_id, crtc_mask,
-                             enc->possible_crtcs);
+    LV_LOG_TRACE("Preferred fb mode: %dx%d", w, h);
+    *width = w;
+    *height = h;
 
-                if(enc->possible_crtcs & crtc_mask)
-                    break;
-            }
+    return 0;
+}
 
-            if(crtc_id > 0) {
-                drm_dev->enc_id = enc->encoder_id;
-                LV_LOG_TRACE("enc_id: %d", drm_dev->enc_id);
-                drm_dev->crtc_id = crtc_id;
-                LV_LOG_TRACE("crtc_id: %d", drm_dev->crtc_id);
-                break;
-            }
+static void drm_setup_fb_mode(drm_device_t *dev)
+{
+    drmModeResPtr res = dev->res;
+    drmModeConnectorPtr conn;
+    drmModeModeInfoPtr mode;
+    int i;
 
-            drmModeFreeEncoder(enc);
-            enc = NULL;
-        }
+    if (dev->mode.width && dev->mode.height)
+        return;
 
-        if(!enc) {
-            LV_LOG_ERROR("suitable encoder not found");
-            goto free_res;
-        }
+    if (!drm_get_preferred_fb_mode(&dev->mode.width, &dev->mode.height))
+        return;
 
-        drmModeFreeEncoder(enc);
-    }
+    dev->mode.width = dev->mode.hdisplay;
+    dev->mode.height = dev->mode.vdisplay;
 
-    drm_dev->crtc_idx = UINT32_MAX;
+    for (i = 0; i < res->count_connectors; i++) {
+        conn = drm_get_connector(dev, res->connectors[i]);
+        if (!conn)
+            continue;
 
-    for(i = 0; i < res->count_crtcs; ++i) {
-        if(drm_dev->crtc_id == res->crtcs[i]) {
-            drm_dev->crtc_idx = i;
-            break;
+        mode = drm_find_best_mode(dev, conn);
+        if (mode) {
+            LV_LOG_TRACE("Best mode for connector(%d): %dx%d",
+                      conn->connector_id, mode->hdisplay, mode->vdisplay);
+            if (dev->mode.width > mode->hdisplay ||
+                    dev->mode.height > mode->vdisplay) {
+                dev->mode.width = mode->hdisplay;
+                dev->mode.height = mode->vdisplay;
+            }
         }
+        drmModeFreeConnector(conn);
     }
+}
 
-    if(drm_dev->crtc_idx == UINT32_MAX) {
-        LV_LOG_ERROR("drm: CRTC not found");
-        goto free_res;
-    }
+static void configure_plane_zpos(drm_device_t *self, int plane_id, uint64_t zpos)
+{
+    drmModeObjectPropertiesPtr props = NULL;
+    drmModePropertyPtr prop = NULL;
+    char *buf;
+    unsigned int i;
 
-    LV_LOG_TRACE("crtc_idx: %d", drm_dev->crtc_idx);
+    if (plane_id <= 0)
+        return;
 
-    return 0;
+    if (drmSetClientCap (self->fd, DRM_CLIENT_CAP_ATOMIC, 1))
+        return;
 
-free_res:
-    drmModeFreeResources(res);
+    props = drmModeObjectGetProperties (self->fd, plane_id,
+          DRM_MODE_OBJECT_PLANE);
+    if (!props)
+        goto out;
+
+    for (i = 0; i < props->count_props; i++) {
+        prop = drmModeGetProperty (self->fd, props->props[i]);
+        if (prop && !strcmp (prop->name, "ZPOS"))
+          break;
+        drmModeFreeProperty (prop);
+        prop = NULL;
+    }
+
+    if (!prop)
+        goto out;
 
-    return -1;
+    drmModeObjectSetProperty (self->fd, plane_id,
+          DRM_MODE_OBJECT_PLANE, props->props[i], zpos);
+out:
+    drmModeFreeProperty (prop);
+    drmModeFreeObjectProperties (props);
 }
 
-static int drm_open(const char * path)
+static void drm_free(drm_device_t * dev)
 {
-    int fd, flags;
-    uint64_t has_dumb;
-    int ret;
-
-    fd = open(path, O_RDWR);
-    if(fd < 0) {
-        LV_LOG_ERROR("cannot open \"%s\"", path);
-        return -1;
-    }
-
-    /* set FD_CLOEXEC flag */
-    if((flags = fcntl(fd, F_GETFD)) < 0 ||
-       fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {
-        LV_LOG_ERROR("fcntl FD_CLOEXEC failed");
-        goto err;
-    }
+    int i;
 
-    /* check capability */
-    ret = drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &has_dumb);
-    if(ret < 0 || has_dumb == 0) {
-        LV_LOG_ERROR("drmGetCap DRM_CAP_DUMB_BUFFER failed or \"%s\" doesn't have dumb "
-                     "buffer", path);
-        goto err;
+    if (dev->res) {
+        drmModeFreeResources(dev->res);
+        dev->res = NULL;
     }
 
-    return fd;
-err:
-    close(fd);
-    return -1;
+    dev->connector_id = 0;
+    dev->crtc_id = 0;
+    dev->plane_id = 0;
+    dev->mode.hdisplay = 0;
+    dev->mode.vdisplay = 0;
 }
 
-static int drm_setup(drm_dev_t * drm_dev, const char * device_path, int64_t connector_id, unsigned int fourcc)
+static int drm_setup(drm_device_t *dev)
 {
+    drmModeConnectorPtr conn = NULL;
+    drmModeModeInfoPtr mode;
+    drmModePlanePtr plane = NULL;
+    drmModeCrtcPtr crtc = NULL;
+    drm_bo_t *crtc_bo;
     int ret;
+    int i, success = 0;
 
-    drm_dev->fd = drm_open(device_path);
-    if(drm_dev->fd < 0)
-        return -1;
-
-    ret = drmSetClientCap(drm_dev->fd, DRM_CLIENT_CAP_ATOMIC, 1);
-    if(ret) {
-        LV_LOG_ERROR("No atomic modesetting support: %s", strerror(errno));
+    dev->res = drmModeGetResources(dev->fd);
+    if (!dev->res) {
+        LV_LOG_ERROR("drm get resource failed");
         goto err;
     }
 
-    ret = drm_find_connector(drm_dev, connector_id);
-    if(ret) {
-        LV_LOG_ERROR("available drm devices not found");
+    conn = drm_find_best_connector(dev);
+    if (!conn) {
+        LV_LOG_ERROR("drm find connector failed");
         goto err;
     }
+    LV_LOG_TRACE("Best connector id: %d", conn->connector_id);
 
-    ret = find_plane(drm_dev, fourcc, &drm_dev->plane_id, drm_dev->crtc_id, drm_dev->crtc_idx);
-    if(ret) {
-        LV_LOG_ERROR("Cannot find plane");
+    mode = drm_find_best_mode(dev, conn);
+    if (!mode) {
+        LV_LOG_ERROR("drm find mode failed");
         goto err;
     }
+    LV_LOG_TRACE("Best mode: %dx%d", mode->hdisplay, mode->vdisplay);
 
-    drm_dev->plane = drmModeGetPlane(drm_dev->fd, drm_dev->plane_id);
-    if(!drm_dev->plane) {
-        LV_LOG_ERROR("Cannot get plane");
+    crtc = drm_find_best_crtc(dev, conn);
+    if (!crtc) {
+        LV_LOG_ERROR("drm find crtc failed");
         goto err;
     }
+    LV_LOG_TRACE("Best crtc: %d", crtc->crtc_id);
 
-    drm_dev->crtc = drmModeGetCrtc(drm_dev->fd, drm_dev->crtc_id);
-    if(!drm_dev->crtc) {
-        LV_LOG_ERROR("Cannot get crtc");
+    plane = drm_find_best_plane(dev, crtc);
+    if (!plane) {
+        LV_LOG_ERROR("drm find plane failed");
         goto err;
     }
-
-    drm_dev->conn = drmModeGetConnector(drm_dev->fd, drm_dev->conn_id);
-    if(!drm_dev->conn) {
-        LV_LOG_ERROR("Cannot get connector");
-        goto err;
+    configure_plane_zpos(dev, plane->plane_id, 1);
+    LV_LOG_USER("Best plane: %d", plane->plane_id);
+    dev->connector_id = conn->connector_id;
+    dev->crtc_id = crtc->crtc_id;
+    dev->plane_id = plane->plane_id;
+    dev->last_fb_id = 0;
+    dev->mode.hdisplay = mode->hdisplay;
+    dev->mode.vdisplay = mode->vdisplay;
+
+    drm_setup_fb_mode(dev);
+    LV_LOG_USER("Drm fb mode: %dx%d", dev->mode.width, dev->mode.height);
+    crtc_bo = malloc_drm_bo(dev, dev->mode.width, dev->mode.height,
+                            DRM_FORMAT);
+    if (crtc_bo)
+    {
+        memset(crtc_bo->ptr, 0x0, crtc_bo->size);
+        ret = drmModeSetCrtc(dev->fd, dev->crtc_id, crtc_bo->fb_id, 0, 0,
+                             dev->con_ids, dev->num_cons, &dev->mode_info);
+        if (ret)
+            LV_LOG_WARN("drmModeSetCrtc failed");
+        free_drm_bo(dev, crtc_bo);
     }
+    success = 1;
+err:
+    drmModeFreeConnector(conn);
+    drmModeFreePlane(plane);
+    drmModeFreeCrtc(crtc);
+    if (!success) {
+        drm_free(dev);
+        return -1;
+    }
+    return 0;
+}
 
-    ret = drm_get_plane_props(drm_dev);
-    if(ret) {
-        LV_LOG_ERROR("Cannot get plane props");
-        goto err;
+static void drm_flip_handler(int fd, unsigned frame, unsigned sec,
+                             unsigned usec, void *data)
+{
+    // data is &dev->waiting_for_flip
+    LV_LOG_TRACE("Page flip received(%d)!, %d, %d, %d, %d", *(int*)data, fd, frame, sec, usec);
+    *(int*)data = 0;
+}
+
+static drm_device_t * drm_init(int bpp)
+{
+    drm_device_t * dev;
+    int ret;
+
+    dev = lv_malloc_zeroed(sizeof(drm_device_t));
+    if (dev == NULL) {
+        LV_LOG_ERROR("allocate device failed");
+        return NULL;
     }
 
-    ret = drm_get_crtc_props(drm_dev);
-    if(ret) {
-        LV_LOG_ERROR("Cannot get crtc props");
-        goto err;
+    dev->fd = drmOpen("rockchip", NULL);
+    if (dev->fd < 0)
+        dev->fd = open("/dev/dri/card0", O_RDWR);
+    if (dev->fd < 0) {
+        LV_LOG_ERROR("drm open failed");
+        goto err_drm_open;
     }
+    fcntl(dev->fd, F_SETFD, FD_CLOEXEC);
 
-    ret = drm_get_conn_props(drm_dev);
-    if(ret) {
-        LV_LOG_ERROR("Cannot get connector props");
-        goto err;
+    drmSetClientCap(dev->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+
+    ret = drm_setup(dev);
+    if (ret) {
+        LV_LOG_ERROR("drm setup failed");
+        goto err_drm_setup;
     }
 
-    drm_dev->drm_event_ctx.version = DRM_EVENT_CONTEXT_VERSION;
-    drm_dev->drm_event_ctx.page_flip_handler = page_flip_handler;
-    drm_dev->fourcc = fourcc;
+    dev->drm_pollfd.fd = dev->fd;
+    dev->drm_pollfd.events = POLLIN;
 
-    LV_LOG_INFO("drm: Found plane_id: %u connector_id: %d crtc_id: %d",
-                drm_dev->plane_id, drm_dev->conn_id, drm_dev->crtc_id);
+    dev->drm_evctx.version = DRM_EVENT_CONTEXT_VERSION;
+    dev->drm_evctx.page_flip_handler = drm_flip_handler;
 
-    LV_LOG_INFO("drm: %dx%d (%dmm X% dmm) pixel format %c%c%c%c",
-                drm_dev->width, drm_dev->height, drm_dev->mmWidth, drm_dev->mmHeight,
-                (fourcc >> 0) & 0xff, (fourcc >> 8) & 0xff, (fourcc >> 16) & 0xff, (fourcc >> 24) & 0xff);
+    return dev;
 
-    return 0;
+err_alloc_fb:
+    drm_free(dev);
+err_drm_setup:
+    drmClose(dev->fd);
+err_drm_open:
+    lv_free(dev);
 
-err:
-    close(drm_dev->fd);
-    return -1;
+    return NULL;
 }
 
-static int drm_allocate_dumb(drm_dev_t * drm_dev, drm_buffer_t * buf)
+static void drm_deinit(drm_device_t * dev)
+{
+    drm_free(dev);
+
+    if (dev->fd > 0)
+        drmClose(dev->fd);
+}
+
+static void drm_wait_flip(drm_device_t* dev, int timeout)
 {
-    struct drm_mode_create_dumb creq;
-    struct drm_mode_map_dumb mreq;
-    uint32_t handles[4] = {0}, pitches[4] = {0}, offsets[4] = {0};
     int ret;
 
-    /* create dumb buffer */
-    lv_memzero(&creq, sizeof(creq));
-    creq.width = drm_dev->width;
-    creq.height = drm_dev->height;
-    creq.bpp = LV_COLOR_DEPTH;
-    ret = drmIoctl(drm_dev->fd, DRM_IOCTL_MODE_CREATE_DUMB, &creq);
-    if(ret < 0) {
-        LV_LOG_ERROR("DRM_IOCTL_MODE_CREATE_DUMB fail");
-        return -1;
+    while (dev->waiting_for_flip) {
+        dev->drm_pollfd.revents = 0;
+        ret = poll(&dev->drm_pollfd, 1, timeout);
+        if (ret <= 0)
+            return;
+
+        drmHandleEvent(dev->fd, &dev->drm_evctx);
     }
+}
 
-    buf->handle = creq.handle;
-    buf->pitch = creq.pitch;
-    buf->size = creq.size;
+static void setdrmdisp(drm_device_t* dev, drm_bo_t *bo)
+{
+    int crtc_x, crtc_y, crtc_w, crtc_h;
+    int ret;
+    int fb = bo->fb_id, sw = dev->mode.width, sh = dev->mode.height;
 
-    /* prepare buffer for memory mapping */
-    lv_memzero(&mreq, sizeof(mreq));
-    mreq.handle = creq.handle;
-    ret = drmIoctl(drm_dev->fd, DRM_IOCTL_MODE_MAP_DUMB, &mreq);
-    if(ret) {
-        LV_LOG_ERROR("DRM_IOCTL_MODE_MAP_DUMB fail");
-        return -1;
+    if (dev == NULL)
+        return;
+
+    crtc_w = dev->mode.width;
+    crtc_h = dev->mode.height;
+    crtc_x = 0;
+    crtc_y = 0;
+
+    LV_LOG_TRACE("Display bo %d(%dx%d) at (%d,%d) %dx%d", fb, sw, sh,
+                 crtc_x, crtc_y, crtc_w, crtc_h);
+    ret = drmModeSetPlane(dev->fd, dev->plane_id, dev->crtc_id, fb, 0,
+                          crtc_x, crtc_y, crtc_w, crtc_h,
+                          0, 0, sw << 16, sh << 16);
+    if (ret) {
+        LV_LOG_ERROR("drm set plane failed");
+        return;
+    }
+    if (1) {
+        // Queue page flip
+        dev->waiting_for_flip = 1;
+        ret = drmModePageFlip(dev->fd, dev->crtc_id, fb,
+                              DRM_MODE_PAGE_FLIP_EVENT, &dev->waiting_for_flip);
+        if (ret) {
+            LV_LOG_ERROR("drm page flip failed");
+            return;
+        }
+        // Wait for last page flip
+        drm_wait_flip(dev, -1);
     }
+}
 
-    buf->offset = mreq.offset;
-    LV_LOG_INFO("size %lu pitch %u offset %u", buf->size, buf->pitch, buf->offset);
+static void *drm_thread(void *arg)
+{
+    drm_device_t * dev = (drm_device_t *)arg;
+    drm_bo_t *bo = NULL;
+    drm_bo_t *vop_buf[2];
+#if LV_DRM_USE_RGA
+    drm_bo_t *gbo = dev->gbo;
+    rga_buffer_t vop_img[2];
+    rga_buffer_t src_img, dst_img, pat_img;
+    im_rect src_rect, dst_rect, pat_rect;
+    int usage = IM_SYNC;
+    int src_fd;
+    int dst_fd;
+    int ret;
+#endif
 
-    /* perform actual memory mapping */
-    buf->map = mmap(0, creq.size, PROT_READ | PROT_WRITE, MAP_SHARED, drm_dev->fd, mreq.offset);
-    if(buf->map == MAP_FAILED) {
-        LV_LOG_ERROR("mmap fail");
-        return -1;
+    vop_buf[0] = dev->vop_buf[0];
+    vop_buf[1] = dev->vop_buf[1];
+
+#if LV_DRM_USE_RGA
+    switch (dev->disp_rot)
+    {
+    case 90: usage |= IM_HAL_TRANSFORM_ROT_90; break;
+    case 180: usage |= IM_HAL_TRANSFORM_ROT_180; break;
+    case 270: usage |= IM_HAL_TRANSFORM_ROT_270; break;
+    default: break;
     }
 
-    /* clear the framebuffer to 0 (= full transparency in ARGB8888) */
-    lv_memzero(buf->map, creq.size);
+    src_img = wrapbuffer_fd(gbo->buf_fd, gbo->w,
+                            gbo->h, RGA_FORMAT,
+                            gbo->pitch / (LV_COLOR_DEPTH >> 3),
+                            gbo->h);
+    vop_img[0] = wrapbuffer_fd(vop_buf[0]->buf_fd, vop_buf[0]->w,
+                               vop_buf[0]->h, RGA_FORMAT,
+                               vop_buf[0]->pitch / (LV_COLOR_DEPTH >> 3),
+                               vop_buf[0]->h);
+    vop_img[1] = wrapbuffer_fd(vop_buf[1]->buf_fd, vop_buf[1]->w,
+                               vop_buf[1]->h, RGA_FORMAT,
+                               vop_buf[1]->pitch / (LV_COLOR_DEPTH >> 3),
+                               vop_buf[1]->h);
+    memset(&pat_img, 0, sizeof(pat_img));
+    memset(&src_rect, 0, sizeof(src_rect));
+    memset(&dst_rect, 0, sizeof(dst_rect));
+    memset(&pat_rect, 0, sizeof(pat_rect));
+#endif
 
-    /* create framebuffer object for the dumb-buffer */
-    handles[0] = creq.handle;
-    pitches[0] = creq.pitch;
-    offsets[0] = 0;
-    ret = drmModeAddFB2(drm_dev->fd, drm_dev->width, drm_dev->height, drm_dev->fourcc,
-                        handles, pitches, offsets, &buf->fb_handle, 0);
-    if(ret) {
-        LV_LOG_ERROR("drmModeAddFB fail");
-        return -1;
+    while (!dev->quit) {
+        pthread_mutex_lock(&dev->mutex);
+        if (dev->draw_update) {
+            bo = (bo == vop_buf[0]) ? vop_buf[1] : vop_buf[0];
+
+#if LV_DRM_USE_RGA
+            dst_img = (bo == vop_buf[0]) ? vop_img[0] : vop_img[1];
+            ret = imcheck_composite(src_img, dst_img, pat_img,
+                                    src_rect, dst_rect, pat_rect);
+            if (ret != IM_STATUS_NOERROR)
+            {
+                LV_LOG_ERROR("%d, check error! %s\n", __LINE__,
+                             imStrError((IM_STATUS)ret));
+            }
+            else
+            {
+                ret = improcess(src_img, dst_img, pat_img,
+                                src_rect, dst_rect, pat_rect, usage);
+                if (ret != IM_STATUS_SUCCESS)
+                    LV_LOG_ERROR("%d, running failed, %s\n", __LINE__,
+                                 imStrError((IM_STATUS)ret));
+            }
+#else
+            for (int i = 0; i < dev->mode.height; i++)
+            {
+                memcpy(bo->ptr + i * bo->pitch,
+                       dev->drm_buff + i * dev->lcd_sw * (LV_COLOR_DEPTH >> 3),
+                       dev->mode.width * (LV_COLOR_DEPTH >> 3));
+            }
+#endif
+            setdrmdisp(dev, bo);
+            dev->draw_update = 0;
+        }
+        pthread_mutex_unlock(&dev->mutex);
+        usleep(100);
     }
+    return NULL;
+}
 
-    return 0;
+static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * color_p)
+{
+    drm_device_t * dev = lv_display_get_driver_data(disp);
+    int32_t x;
+    int32_t y;
+    int32_t w = lv_area_get_width(area);
+    int32_t h = lv_area_get_height(area);
+
+    pthread_mutex_lock(&dev->mutex);
+
+    for(y = area->y1; y <= area->y2; y++) {
+        lv_color_t *ptr = (lv_color_t*)(dev->drm_buff + (y * dev->lcd_sw + area->x1) * (LV_COLOR_DEPTH >> 3));
+        memcpy(ptr, color_p, w * (LV_COLOR_DEPTH >> 3));
+        color_p += w * (LV_COLOR_DEPTH >> 3);
+    }
+    if(lv_display_flush_is_last(disp))
+        dev->draw_update = 1;
+    pthread_mutex_unlock(&dev->mutex);
+
+    lv_display_flush_ready(disp);
 }
 
-static int drm_setup_buffers(drm_dev_t * drm_dev)
+static void drm_buffer_setup(drm_device_t * dev)
 {
-    int ret;
+    int buf_w, buf_h;
 
-    /*Allocate DUMB buffers*/
-    ret = drm_allocate_dumb(drm_dev, &drm_dev->drm_bufs[0]);
-    if(ret)
-        return ret;
+    LV_LOG_USER("bit depth %d", LV_COLOR_DEPTH);
 
-    ret = drm_allocate_dumb(drm_dev, &drm_dev->drm_bufs[1]);
-    if(ret)
-        return ret;
+    if ((dev->disp_rot == 0) || (dev->disp_rot == 180))
+    {
+        buf_w = dev->mode.width;
+        buf_h = dev->mode.height;
+    }
+    else
+    {
+        buf_w = dev->mode.height;
+        buf_h = dev->mode.width;
+    }
+#if LV_DRM_USE_RGA
+    dev->gbo = malloc_drm_bo(dev, buf_w, buf_h, DRM_FORMAT);
+    dev->drm_buff = dev->gbo->ptr;
+    dev->lcd_sw = dev->gbo->pitch / (LV_COLOR_DEPTH >> 3);
+    c_RkRgaInit();
+#else
+    dev->drm_buff = malloc(buf_w * buf_h * (LV_COLOR_DEPTH >> 3));
+    dev->lcd_sw = buf_w;
+#endif
+    dev->vop_buf[0] = malloc_drm_bo(dev, dev->mode.width, dev->mode.height,
+                                    DRM_FORMAT);
+    dev->vop_buf[1] = malloc_drm_bo(dev, dev->mode.width, dev->mode.height,
+                                    DRM_FORMAT);
+    LV_LOG_USER("DRM subsystem and buffer mapped successfully");
+}
 
-    return 0;
+static void drm_buffer_destroy(drm_device_t * dev)
+{
+#if LV_DRM_USE_RGA
+    free_drm_bo(dev, dev->gbo);
+#else
+    free(dev->drm_buff);
+    free(dev->disp_buf);
+#endif
+    free_drm_bo(dev, dev->vop_buf[0]);
+    free_drm_bo(dev, dev->vop_buf[1]);
 }
 
-static void drm_flush_wait(lv_display_t * disp)
+lv_display_t * lv_drm_disp_create(int rot)
 {
-    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    lv_display_t * disp;
 
-    struct pollfd pfd;
-    pfd.fd = drm_dev->fd;
-    pfd.events = POLLIN;
+    drm_device_t * dev = drm_init(32);
+    if (!dev)
+        return NULL;
+#if LV_DRM_USE_RGA
+    dev->disp_rot = rot;
+#endif
+    drm_buffer_setup(dev);
 
-    while(drm_dev->req) {
-        int ret;
-        do {
-            ret = poll(&pfd, 1, -1);
-        } while(ret == -1 && errno == EINTR);
+    if ((dev->disp_rot == 0) || (dev->disp_rot == 180))
+        disp = lv_display_create(dev->mode.width, dev->mode.height);
+    else
+        disp = lv_display_create(dev->mode.height, dev->mode.width);
 
-        if(ret > 0)
-            drmHandleEvent(drm_dev->fd, &drm_dev->drm_event_ctx);
-        else {
-            LV_LOG_ERROR("poll failed: %s", strerror(errno));
-            return;
-        }
+    if (disp == NULL) {
+        LV_LOG_ERROR("lv_display_create failed");
+        return NULL;
     }
+
+    int size = dev->mode.width * dev->mode.height * (LV_COLOR_DEPTH >> 3);
+    dev->disp_buf = lv_malloc(size);
+    lv_display_set_driver_data(disp, dev);
+    lv_display_set_flush_cb(disp, drm_flush);
+    lv_display_set_buffers(disp, dev->disp_buf, NULL, size,
+                           LV_DISPLAY_RENDER_MODE_PARTIAL);
+
+    pthread_mutex_init(&dev->mutex, NULL);
+    pthread_create(&dev->pid, NULL, drm_thread, dev);
+
+    return disp;
 }
 
-static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
+int lv_drm_disp_delete(lv_display_t * disp)
 {
-    if(!lv_display_flush_is_last(disp)) return;
+    drm_device_t* dev = lv_display_get_driver_data(disp);
 
-    LV_UNUSED(area);
-    LV_UNUSED(px_map);
-    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if (!dev)
+        goto end;
 
-    for(int idx = 0; idx < 2; idx++) {
-        if(drm_dev->drm_bufs[idx].map == px_map) {
-            /*Request buffer swap*/
-            if(drm_dmabuf_set_plane(drm_dev, &drm_dev->drm_bufs[idx])) {
-                LV_LOG_ERROR("Flush fail");
-                return;
-            }
-            else
-                LV_LOG_TRACE("Flush done");
-        }
-    }
+    dev->quit = 0;
+    pthread_join(dev->pid, NULL);
+
+    drm_buffer_destroy(dev);
+
+    drm_deinit(dev);
+
+    lv_free(dev->disp_buf);
+    lv_free(dev);
+end:
+    lv_display_delete(disp);
+
+    return 0;
 }
 
-#endif /*LV_USE_LINUX_DRM*/
+#endif
diff --git a/src/drivers/display/drm/lv_linux_drm.h b/src/drivers/display/drm/lv_linux_drm.h
index a75d195..916b536 100644
--- a/src/drivers/display/drm/lv_linux_drm.h
+++ b/src/drivers/display/drm/lv_linux_drm.h
@@ -1,5 +1,5 @@
 /**
- * @file lv_linux_drm_h
+ * @file drm.h
  *
  */
 
@@ -13,11 +13,19 @@ extern "C" {
 /*********************
  *      INCLUDES
  *********************/
-
-#include "../../../display/lv_display.h"
+#include <lvgl.h>
 
 #if LV_USE_LINUX_DRM
 
+#ifndef LV_DRM_USE_RGA
+#define LV_DRM_USE_RGA 0
+#endif
+
+#if LV_DRM_USE_RGA
+#include <rga/im2d.h>
+#include <rga/rga.h>
+#include <rga/RgaApi.h>
+#endif
 /*********************
  *      DEFINES
  *********************/
@@ -29,18 +37,17 @@ extern "C" {
 /**********************
  * GLOBAL PROTOTYPES
  **********************/
-lv_display_t * lv_linux_drm_create(void);
-
-void lv_linux_drm_set_file(lv_display_t * disp, const char * file, int64_t connector_id);
+lv_display_t * lv_drm_disp_create(int rot);
+int lv_drm_disp_delete(lv_display_t * disp);
 
 /**********************
  *      MACROS
  **********************/
 
-#endif /* LV_USE_LINUX_DRM */
+#endif  /*LV_USE_LINUX_DRM*/
 
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
 
-#endif /* LV_LINUX_DRM_H */
+#endif /*DRM_H*/
-- 
2.25.1


/**
  * Copyright (c) 2024Rockchip Electronics Co., Ltd
  *
  * SPDX-License-Identifier: Apache-2.0
  ******************************************************************************
  * @file    crypto_test.c
  * @author  Troy Lin
  * @version V0.1
  * @date    21-Mar-2024
  * @brief   crypto test for symmetric/hash/extpmod/rng
  *
  ******************************************************************************
  */

#include <rtdevice.h>
#include <rthw.h>
#include <rtthread.h>

#if defined(RT_USING_COMMON_TEST_CRYPTO) && defined(RT_USING_HWCRYPTO)

#include <board.h>
#include <hwcrypto.h>
#include <string.h>
#include <stdlib.h>
#include <drv_heap.h>

#define CRYP_DATA_LEN   80

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x) / sizeof((x)[0]))
#endif

struct key_map
{
    hwcrypto_type type;
    const char *name;
};

#define __is_print(ch) ((unsigned int)((ch) - ' ') < 127u - ' ')
static void dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
    unsigned char *buf = (unsigned char *)ptr;
    int i, j;

    for (i = 0; i < buflen; i += 16)
    {
        rt_kprintf("%08X: ", i);

        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                rt_kprintf("%02X ", buf[i + j]);
            }
            else
            {
                rt_kprintf("   ");
            }
        }
        rt_kprintf(" ");

        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                rt_kprintf("%c", __is_print(buf[i + j]) ? buf[i + j] : '.');
            }
        }
        rt_kprintf("\n");
    }
}

#if defined(RT_HWCRYPTO_USING_RNG)
static rt_err_t hw_rng_sample(int random_num)
{
    rt_err_t result = RT_EOK;
    int i = 0, num0 = 0, num1 = 0;

    if (random_num == 0)
    {
        return RT_ERROR;
    }

    for (i = 0; i < random_num; i++)
    {
        result = rt_hwcrypto_rng_update();
        rt_kprintf("%d ", result);
        result % 2 ? num1++ : num0++;
    }
    rt_kprintf("\neven numbers : %d, odd numbers: %d\n", num1, num0);

    return RT_EOK;
}
#endif

#if defined(RT_HWCRYPTO_USING_CRC)
static void hw_crc_sample(uint8_t *temp, int size)
{
    struct rt_hwcrypto_ctx *ctx;
    rt_uint32_t result = 0;

    struct hwcrypto_crc_cfg cfg =
    {
        .last_val = 0xFFFFFFFF,
        .poly     = 0x04C11DB7,
        .width    = 32,
        .xorout   = 0x00000000,
        .flags    = 0,
    };

    ctx = rt_hwcrypto_crc_create(rt_hwcrypto_dev_default(), HWCRYPTO_CRC_CRC32);
    rt_hwcrypto_crc_cfg(ctx, &cfg);

    result = rt_hwcrypto_crc_update(ctx, temp, size);

    rt_kprintf("crc result: %x \n", result);

    rt_hwcrypto_crc_destroy(ctx);
}
#endif

#define CAMPARE_RESULT(name, expect, actual) do { \
        if(rt_memcmp((actual), (expect), sizeof(expect)/sizeof((expect)[0])) != 0) \
        { \
            rt_kprintf("Except %s result:\n", name); \
            dump_hex(expect, sizeof(expect)); \
            rt_kprintf("Actual %s result:\n", name); \
            dump_hex(actual, sizeof(expect)); \
            rt_kprintf("%s Test error, The actual result is not equal to the except result\n", name); \
        } \
        else \
        { \
            rt_kprintf("%s Test success!\n", name); \
        } \
    } while (0)

#define CALC_RATE_MPBS(bytes, ms)   (((bytes) / 1024) / (ms))

static const char *hwcrypto_type2name(hwcrypto_type type)
{
    struct key_map key_pairs[] =
    {
        {HWCRYPTO_TYPE_AES_ECB, "AES_ECB"},
        {HWCRYPTO_TYPE_AES_CBC, "AES_CBC"},
        {HWCRYPTO_TYPE_AES_CFB, "AES_CFB"},
        {HWCRYPTO_TYPE_AES_CTR, "AES_CTR"},
        {HWCRYPTO_TYPE_AES_OFB, "AES_OFB"},

        {HWCRYPTO_TYPE_MD5, "HASH_MD5"},
        {HWCRYPTO_TYPE_SHA1, "HASH_SHA1"},
        {HWCRYPTO_TYPE_SHA224, "HASH_SHA224"},
        {HWCRYPTO_TYPE_SHA256, "HASH_SHA256"},
        {HWCRYPTO_TYPE_SHA384, "HASH_SHA384"},
        {HWCRYPTO_TYPE_SHA512, "HASH_SHA512"},
    };

    for (int i = 0; i < ARRAY_SIZE(key_pairs); i++)
    {
        if (key_pairs[i].type == type)
            return key_pairs[i].name;
    }

    return "Unknown";
}

static rt_err_t hw_hash_calc(hwcrypto_type type, const rt_uint8_t *msg, rt_size_t msg_len,
                             rt_uint8_t *hash, rt_size_t hash_len)
{
    rt_err_t ret;
    struct rt_hwcrypto_ctx *ctx = RT_NULL;
    ctx = rt_hwcrypto_hash_create(rt_hwcrypto_dev_default(), type);
    if (ctx == RT_NULL)
    {
        rt_kprintf("create %s context err!\n", hwcrypto_type2name(type));
        return -RT_ENOSYS;
    }

    ret = rt_hwcrypto_hash_update(ctx, msg, msg_len);
    if (ret)
    {
        rt_kprintf("update %s hash err = %d!\n", hwcrypto_type2name(type), ret);
        goto exit;
    }

    /* get md5 result */
    ret = rt_hwcrypto_hash_finish(ctx, hash, hash_len);
exit:
    rt_hwcrypto_hash_destroy(ctx);

    return ret;
}

static void hw_hash_sample(void)
{
    const uint8_t msg[] = "RT-Thread was born in 2006, it is an open source, neutral, and community-based real-time operating system (RTOS).";
    static uint8_t sha1_except[20] =
    {
        0xff, 0x3c, 0x95, 0x54, 0x95, 0xf0, 0xad, 0x02,
        0x1b, 0xa8, 0xbc, 0xa2, 0x2e, 0xa5, 0xb0, 0x62,
        0x1b, 0xdf, 0x7f, 0xec
    };
    static uint8_t md5_except[16] =
    {
        0x40, 0x86, 0x03, 0x80, 0x0d, 0x8c, 0xb9, 0x4c,
        0xd6, 0x7d, 0x28, 0xfc, 0xf6, 0xc3, 0xac, 0x8b
    };
    static uint8_t sha224_except[28] =
    {
        0x6f, 0x62, 0x52, 0x7d, 0x80, 0xe6, 0x9f, 0x82,
        0x78, 0x7a, 0x46, 0x91, 0xb0, 0xe9, 0x64, 0x89,
        0xe6, 0xc3, 0x6b, 0x7e, 0xcf, 0xca, 0x11, 0x42,
        0xc8, 0x77, 0x13, 0x79
    };
    static uint8_t sha256_except[32] =
    {
        0x74, 0x19, 0xb9, 0x0e, 0xd1, 0x46, 0x37, 0x0a,
        0x55, 0x18, 0x26, 0x6c, 0x50, 0xd8, 0x71, 0x34,
        0xfa, 0x1f, 0x5f, 0x5f, 0xe4, 0x9a, 0xe9, 0x40,
        0x0a, 0x7d, 0xa0, 0x26, 0x1b, 0x86, 0x67, 0x45
    };
    static uint8_t hash_out[64];
    size_t msg_len = rt_strlen((char const *)msg);

    rt_kprintf("======================== Hash Test start ========================\n");
    rt_kprintf("Hash Test string: \n");
    dump_hex(msg, sizeof(msg));

    /* sh1 test*/
    hw_hash_calc(HWCRYPTO_TYPE_SHA1, msg, msg_len, hash_out, sizeof(sha1_except));
    CAMPARE_RESULT("sha1", sha1_except, hash_out);

    /* md5 test*/
    hw_hash_calc(HWCRYPTO_TYPE_MD5, msg, msg_len, hash_out, sizeof(md5_except));
    CAMPARE_RESULT("md5", md5_except, hash_out);

    /* sha224 test */
    hw_hash_calc(HWCRYPTO_TYPE_SHA224, msg, msg_len, hash_out, sizeof(sha224_except));
    CAMPARE_RESULT("sha224", sha224_except, hash_out);

    /* sha256 test*/
    hw_hash_calc(HWCRYPTO_TYPE_SHA256, msg, msg_len, hash_out, sizeof(sha256_except));
    CAMPARE_RESULT("sha256", sha256_except, hash_out);

    rt_kprintf("======================== Hash Test over! ========================\n");
}

static rt_err_t hw_hash_perf_one(hwcrypto_type type)
{
#if defined(RT_USING_LARGE_HEAP)
    rt_tick_t start, end;
    uint8_t *buffer = RT_NULL;
    uint8_t hash_out[16];
    rt_uint32_t buf_len = 1 * 1024 * 1024;
    rt_err_t ret;
    struct rt_hwcrypto_ctx *ctx = RT_NULL;
    int i = 0;
    const char *name = hwcrypto_type2name(type);

    /* Populating test data */
    buffer = rt_malloc_large(buf_len);
    if (!buffer)
    {
        rt_kprintf("malloc buffer %uByte failed!\n", buf_len);
        goto exit;
    }

    ctx = rt_hwcrypto_hash_create(rt_hwcrypto_dev_default(), type);
    if (ctx == RT_NULL)
    {
        rt_kprintf("create hash[%08x] context err!\n", type);
        return -RT_ENOSYS;
    }

    start = rt_tick_get_millisecond();

    /* cal 100MByte */
    for (i = 0; i < 100; i++)
    {
        ret = rt_hwcrypto_hash_update(ctx, buffer, buf_len);
        if (ret)
        {
            rt_kprintf("update hash err = %d!\n", ret);
            goto exit;
        }
    }

    /* get md5 result */
    ret = rt_hwcrypto_hash_finish(ctx, hash_out, sizeof(hash_out));
    end = rt_tick_get_millisecond();

    uint32_t cost_ms = end - start;
    rt_kprintf("100M %-12s cost %ums, perf = %uMB/s\r\n", name, cost_ms, CALC_RATE_MPBS(i * buf_len, cost_ms));

exit:
    rt_hwcrypto_hash_destroy(ctx);

    if (buffer)
        rt_free_large(buffer);

    return ret;
#else
    rt_kprintf("Please enable RT_USING_LARGE_HEAP first.\n");
    return 0;
#endif
}

static void hw_hash_perf_sample(void)
{
    rt_kprintf("======================== Hash Perf Test over! ========================\n");

    hw_hash_perf_one(HWCRYPTO_TYPE_SHA1);
    hw_hash_perf_one(HWCRYPTO_TYPE_MD5);
    hw_hash_perf_one(HWCRYPTO_TYPE_SHA224);
    hw_hash_perf_one(HWCRYPTO_TYPE_SHA256);

    rt_kprintf("======================== Hash Perf Test over! ========================\n");
}

static void hw_multi_hash_sample(void)
{
    struct rt_hwcrypto_ctx *ctx_sha1 = RT_NULL;
    struct rt_hwcrypto_ctx *ctx_sha256 = RT_NULL;
    const uint8_t hash_input[] = "RT-Thread was born in 2006, it is an open source, neutral, and community-based real-time operating system (RTOS).";
    uint32_t hash_input_len;
    static uint8_t sha1_output[20];
    static uint8_t sha1_except[20] =
    {
        0xff, 0x3c, 0x95, 0x54, 0x95, 0xf0, 0xad, 0x02,
        0x1b, 0xa8, 0xbc, 0xa2, 0x2e, 0xa5, 0xb0, 0x62,
        0x1b, 0xdf, 0x7f, 0xec
    };

    static uint8_t sha256_output[32];
    static uint8_t sha256_except[32] =
    {
        0x74, 0x19, 0xb9, 0x0e, 0xd1, 0x46, 0x37, 0x0a,
        0x55, 0x18, 0x26, 0x6c, 0x50, 0xd8, 0x71, 0x34,
        0xfa, 0x1f, 0x5f, 0x5f, 0xe4, 0x9a, 0xe9, 0x40,
        0x0a, 0x7d, 0xa0, 0x26, 0x1b, 0x86, 0x67, 0x45
    };

    rt_kprintf("======================== Hash Multithread Test start ========================\n");
    rt_kprintf("Hash Test string: \n");
    dump_hex(hash_input, sizeof(hash_input));

    hash_input_len = rt_strlen((char const *)hash_input);

    /* sh1 test*/
    rt_kprintf("\n============ SHA1 Test Start ============\n");
    ctx_sha1 = rt_hwcrypto_hash_create(rt_hwcrypto_dev_default(), HWCRYPTO_TYPE_SHA1);
    if (ctx_sha1 == RT_NULL)
    {
        rt_kprintf("create hash[%08x] context err!\n", HWCRYPTO_TYPE_SHA1);
        return ;
    }


    ctx_sha256 = rt_hwcrypto_hash_create(rt_hwcrypto_dev_default(), HWCRYPTO_TYPE_SHA256);
    if (ctx_sha256 == RT_NULL)
    {
        rt_kprintf("create hash[%08x] context err!\n", HWCRYPTO_TYPE_SHA256);
        return ;
    }

    /* start sha1/sha256 */
    rt_hwcrypto_hash_update(ctx_sha1, hash_input + 0, 7);

    rt_hwcrypto_hash_update(ctx_sha256, hash_input + 0, 11);

    rt_hwcrypto_hash_update(ctx_sha1, hash_input + 7, 8);

    rt_hwcrypto_hash_update(ctx_sha256, hash_input + 11, 5);

    rt_hwcrypto_hash_update(ctx_sha1, hash_input + 15, 9);

    rt_hwcrypto_hash_update(ctx_sha256, hash_input + 16, 21);

    rt_hwcrypto_hash_update(ctx_sha1, hash_input + 24, hash_input_len - 24);

    rt_hwcrypto_hash_update(ctx_sha256, hash_input + 37, hash_input_len - 37);

    /* get sha1 result */
    rt_hwcrypto_hash_finish(ctx_sha1, sha1_output, sizeof(sha1_output));

    /* get sha256 result */
    rt_hwcrypto_hash_finish(ctx_sha256, sha256_output, sizeof(sha256_output));


    CAMPARE_RESULT("sha1", sha1_except, sha1_output);
    CAMPARE_RESULT("sha256", sha256_except, sha256_output);

    /* destory */
    rt_hwcrypto_hash_destroy(ctx_sha1);
    rt_hwcrypto_hash_destroy(ctx_sha256);

    rt_kprintf("======================== Hash Multithread Test over! ========================\n");
}

/* key*/
static const rt_uint8_t cryp_key[32] =
{
    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
};

static int hw_cryp_calc(const rt_uint8_t in[CRYP_DATA_LEN], rt_uint8_t out[CRYP_DATA_LEN], hwcrypto_type type, hwcrypto_mode mode)
{
    struct rt_hwcrypto_ctx *ctx;
    int ret = 0;

    ctx = rt_hwcrypto_symmetric_create(rt_hwcrypto_dev_default(), type);
    if (ctx == RT_NULL)
    {
        rt_kprintf("create hwcrypto type[%d], mode[%d] context err!\n", type, mode);
        return -RT_ERROR;
    }

    ret |= rt_hwcrypto_symmetric_setkey(ctx, cryp_key, sizeof(cryp_key) * 8);
    ret |= rt_hwcrypto_symmetric_crypt(ctx, mode, CRYP_DATA_LEN, in, out);
    rt_hwcrypto_symmetric_destroy(ctx);

    return ret;
}

static int hw_cryp_sample_item(hwcrypto_type type)
{
    rt_uint8_t buf_in[CRYP_DATA_LEN];
    rt_uint8_t buf_out1[CRYP_DATA_LEN];
    rt_uint8_t buf_out2[CRYP_DATA_LEN];
    int i, ret;

    /* Populating test data */
    for (i = 0; i < sizeof(buf_in); i++)
    {
        buf_in[i] = i;
    }

    rt_memset(buf_out1, 0, sizeof(buf_out1));
    rt_memset(buf_out2, 0, sizeof(buf_out1));

    /* encrypt */
    ret = hw_cryp_calc(buf_in, buf_out1, type, HWCRYPTO_MODE_ENCRYPT);
    if (ret)
    {
        rt_kprintf("%s encrypt failed.\n", hwcrypto_type2name(type));
        goto exit;
    }

    /* decrypt */
    ret = hw_cryp_calc(buf_out1, buf_out2, type, HWCRYPTO_MODE_DECRYPT);
    if (ret)
    {
        rt_kprintf("%s decrypt failed.\n", hwcrypto_type2name(type));
        goto exit;
    }

    CAMPARE_RESULT(hwcrypto_type2name(type), buf_in, buf_out2);
exit:
    return ret;
}

static void hw_cryp_sample(void)
{
    hw_cryp_sample_item(HWCRYPTO_TYPE_AES_ECB);
    hw_cryp_sample_item(HWCRYPTO_TYPE_AES_CBC);
    hw_cryp_sample_item(HWCRYPTO_TYPE_AES_CFB);
    hw_cryp_sample_item(HWCRYPTO_TYPE_AES_CTR);
    hw_cryp_sample_item(HWCRYPTO_TYPE_AES_OFB);
}

static void hw_cryp_perf_sample_item(hwcrypto_type type)
{
#if defined(RT_USING_LARGE_HEAP)
    rt_uint8_t key[32];
    rt_uint8_t *buffer = RT_NULL;
    rt_uint32_t buf_len = 1 * 1024 * 1024;
    int i;
    rt_tick_t start, end;

    /* Populating test data */
    buffer = rt_malloc_large(buf_len);
    if (!buffer)
    {
        rt_kprintf("malloc buffer %uByte failed!\n", buf_len);
        goto exit;
    }

    rt_memset(key, 0xcd, sizeof(key));
    rt_memset(buffer, 0xab, buf_len);

    struct rt_hwcrypto_ctx *ctx;

    ctx = rt_hwcrypto_symmetric_create(rt_hwcrypto_dev_default(), type);
    if (ctx == RT_NULL)
    {
        rt_kprintf("create AES-CBC context err!");
        return;
    }

    rt_hwcrypto_symmetric_setkey(ctx, key, 256);

    start = rt_tick_get_millisecond();

    /* cal 100MByte */
    for (i = 0; i < 100; i++)
    {
        rt_hwcrypto_symmetric_crypt(ctx, HWCRYPTO_MODE_ENCRYPT, buf_len, buffer, buffer);
    }

    end = rt_tick_get_millisecond();

    uint32_t cost_ms = end - start;
    rt_kprintf("100M %-12s cost %ums, perf = %uMB/s\r\n",
               hwcrypto_type2name(type), cost_ms, CALC_RATE_MPBS(i * buf_len, cost_ms));

    rt_hwcrypto_symmetric_destroy(ctx);

exit:
    if (buffer)
        rt_free_large(buffer);
#else
    rt_kprintf("Please enable RT_USING_LARGE_HEAP first.\n");
#endif
}

static void hw_cryp_perf_sample(void)
{
    hw_cryp_perf_sample_item(HWCRYPTO_TYPE_AES_ECB);
    hw_cryp_perf_sample_item(HWCRYPTO_TYPE_AES_CBC);
    hw_cryp_perf_sample_item(HWCRYPTO_TYPE_AES_CFB);
    hw_cryp_perf_sample_item(HWCRYPTO_TYPE_AES_CTR);
    hw_cryp_perf_sample_item(HWCRYPTO_TYPE_AES_OFB);
}

#if defined(RT_HWCRYPTO_USING_BIGNUM)

/* big endia data */
const rt_uint8_t rsa4096_n[] =
{
    0x5c, 0xfe, 0x20, 0x2f, 0x66, 0x2c, 0x77, 0x19,
    0x5c, 0x06, 0x30, 0xd7, 0x49, 0xd8, 0xf6, 0x61,
    0x8d, 0x5c, 0xa4, 0x9d, 0x4a, 0xee, 0xff, 0xef,
    0x0b, 0xfa, 0x3d, 0x44, 0x9f, 0xb5, 0x81, 0xe9,
    0x4c, 0xe5, 0xd4, 0x07, 0x0b, 0x21, 0x31, 0xea,
    0x05, 0x15, 0x7e, 0x41, 0x75, 0xcb, 0x43, 0x12,
    0x25, 0x4e, 0xaa, 0xbd, 0xe9, 0xe2, 0xe9, 0xd2,
    0x3f, 0xa1, 0x73, 0xa8, 0x67, 0x3b, 0xca, 0x12,
    0x8c, 0x04, 0x80, 0x33, 0x4c, 0xc3, 0x67, 0xae,
    0x07, 0xb8, 0xb5, 0x75, 0x6c, 0xc0, 0x41, 0x88,
    0xdb, 0x6d, 0x93, 0x11, 0xcf, 0xee, 0xfb, 0xb9,
    0x53, 0x7a, 0x5e, 0x2c, 0x18, 0x5a, 0x75, 0xfa,
    0x1d, 0x30, 0x23, 0x3f, 0xc1, 0x90, 0xc8, 0x0e,
    0xf6, 0x06, 0xb2, 0x84, 0xe0, 0x93, 0x20, 0xce,
    0x09, 0xe9, 0xeb, 0x11, 0x51, 0x0b, 0xa4, 0x37,
    0x2b, 0x71, 0x8d, 0x14, 0x6a, 0x59, 0x54, 0xff,
    0x6f, 0xc1, 0xcd, 0xb7, 0x13, 0x7a, 0x87, 0x54,
    0x7e, 0x0b, 0x56, 0x54, 0x65, 0xfe, 0x5b, 0xb4,
    0x2b, 0x44, 0x89, 0xaa, 0xba, 0x71, 0x29, 0x71,
    0x3c, 0xbb, 0x70, 0xd5, 0x14, 0x3d, 0x4c, 0xac,
    0x71, 0x4a, 0x2c, 0x36, 0x11, 0x54, 0xa3, 0xe6,
    0x74, 0x52, 0x72, 0x5f, 0x18, 0x19, 0xb2, 0xdc,
    0xdd, 0x04, 0x24, 0x9b, 0xd5, 0x49, 0x19, 0xf6,
    0xc5, 0xce, 0x46, 0x46, 0xee, 0x2a, 0x2e, 0x56,
    0xd2, 0x70, 0x56, 0x67, 0x8d, 0xa6, 0x7d, 0xa4,
    0xfb, 0xb8, 0x60, 0xda, 0x71, 0x96, 0xb9, 0xd0,
    0x96, 0x98, 0xcf, 0x7f, 0x0f, 0x88, 0x91, 0xf0,
    0xb8, 0x37, 0x5e, 0xe1, 0x01, 0x9f, 0x64, 0x79,
    0x80, 0xc8, 0xbd, 0xe9, 0xe1, 0x77, 0x77, 0x47,
    0xa5, 0x19, 0x84, 0x79, 0xdb, 0xfd, 0x3b, 0x17,
    0x3e, 0x8b, 0x5f, 0xdc, 0xa0, 0x59, 0x33, 0x00,
    0x0b, 0xa8, 0x20, 0xcf, 0xe3, 0x75, 0x14, 0x3d,
    0x59, 0x56, 0xca, 0xd4, 0xae, 0x74, 0x1b, 0x88,
    0xef, 0x76, 0x8f, 0x41, 0xd4, 0xd2, 0xa6, 0xce,
    0x0a, 0x04, 0x92, 0xb3, 0x62, 0x77, 0x67, 0xfe,
    0x8e, 0x7b, 0x09, 0x7d, 0xd9, 0x10, 0xe6, 0x0f,
    0xce, 0xac, 0x83, 0x30, 0x7d, 0x02, 0xca, 0xac,
    0xf4, 0x32, 0x02, 0x12, 0x71, 0x3f, 0x99, 0x15,
    0xfd, 0x16, 0x7b, 0x42, 0x94, 0xc8, 0x46, 0x37,
    0x2d, 0x4d, 0x9c, 0xee, 0x15, 0xdd, 0xd7, 0x04,
    0x65, 0x19, 0xf6, 0x68, 0xff, 0x47, 0x34, 0x7a,
    0x40, 0xde, 0xb9, 0x38, 0x4e, 0x98, 0xe8, 0x41,
    0x1f, 0x99, 0x2c, 0x83, 0x10, 0x3a, 0xa6, 0xb0,
    0xa9, 0x63, 0x3d, 0x28, 0x0c, 0x5a, 0x34, 0x8c,
    0xb5, 0xa8, 0x7a, 0xb7, 0x6a, 0xf4, 0x85, 0xbd,
    0xc6, 0x7f, 0x64, 0x47, 0x80, 0x78, 0xe0, 0xf2,
    0x4a, 0xaa, 0x85, 0x9a, 0x33, 0x86, 0x80, 0x0d,
    0xf8, 0x6f, 0xbf, 0x32, 0x5b, 0x0a, 0x7b, 0xb4,
    0x4c, 0x3f, 0x4c, 0xa5, 0x03, 0x4b, 0x42, 0x09,
    0xce, 0xeb, 0x49, 0x59, 0xdf, 0x04, 0xfd, 0xdd,
    0xc1, 0xe9, 0x5a, 0xc0, 0x8e, 0x5e, 0xa8, 0xee,
    0x42, 0x17, 0x1b, 0x15, 0xfc, 0x22, 0x79, 0xb7,
    0x1f, 0x8f, 0xa3, 0x0f, 0x9f, 0x80, 0x45, 0x3c,
    0xda, 0xa0, 0x02, 0x8f, 0x26, 0x5c, 0xc9, 0x79,
    0x00, 0x92, 0x69, 0x73, 0xfd, 0xbe, 0x52, 0xf2,
    0xb1, 0xb1, 0x0d, 0x10, 0x0c, 0xa6, 0x11, 0x38,
    0x97, 0xbf, 0x3b, 0x65, 0x6a, 0x9c, 0x14, 0x13,
    0xa1, 0x8e, 0x39, 0x52, 0xfc, 0xd8, 0xe2, 0x41,
    0x2e, 0x67, 0x59, 0x3e, 0xbd, 0x81, 0x70, 0x59,
    0x1e, 0xfa, 0x14, 0xce, 0xfe, 0xeb, 0xa9, 0xe1,
    0xa8, 0x80, 0x85, 0x1d, 0xf8, 0x67, 0x26, 0xc6,
    0x8f, 0x64, 0x74, 0x32, 0x02, 0xea, 0x59, 0xaf,
    0xc8, 0x5b, 0x4f, 0x3c, 0xa5, 0x3a, 0xb9, 0x82,
    0xbb, 0x0a, 0x95, 0x21, 0x36, 0x76, 0xcf, 0x3f,
};

const rt_uint8_t rsa4096_e[] =
{
    0x01, 0x00, 0x01
};

const rt_uint8_t rsa4096_d[] =
{
    0x37, 0x56, 0xa3, 0x20, 0x91, 0xd4, 0xf4, 0x2b,
    0x0b, 0x30, 0x43, 0xf0, 0x59, 0xe9, 0xda, 0xf4,
    0xc2, 0x82, 0xd7, 0x13, 0x23, 0x7c, 0x86, 0xa1,
    0x62, 0xa7, 0x4f, 0xbe, 0x7e, 0xac, 0x2c, 0xdb,
    0x00, 0xff, 0xe3, 0xe5, 0x2d, 0x22, 0x5b, 0xe9,
    0xbf, 0x8c, 0xc2, 0xcd, 0x81, 0xa3, 0xac, 0x0e,
    0x28, 0x55, 0x60, 0x16, 0x14, 0x11, 0x0c, 0xc4,
    0x29, 0x49, 0x92, 0xe2, 0x2c, 0x4c, 0xd0, 0x3b,
    0xa9, 0x47, 0x24, 0x63, 0x62, 0xd3, 0x05, 0xe7,
    0xf2, 0x80, 0x60, 0xbb, 0xb8, 0x33, 0xd0, 0xcb,
    0xf8, 0x88, 0x84, 0x74, 0x9d, 0x20, 0xc2, 0x7b,
    0xce, 0xc9, 0x8b, 0x31, 0x02, 0x6d, 0x12, 0xb7,
    0xfc, 0x96, 0xa0, 0xe3, 0x57, 0xf5, 0x28, 0x98,
    0x7e, 0xa0, 0x0d, 0xac, 0x35, 0x58, 0x58, 0xb5,
    0x44, 0x01, 0x07, 0xfa, 0x0e, 0x18, 0xb7, 0x68,
    0x7d, 0x59, 0xdd, 0x72, 0xc0, 0xb6, 0xd8, 0x76,
    0x09, 0xb3, 0x73, 0x0f, 0xf7, 0x6f, 0x7b, 0x09,
    0x34, 0xd8, 0xda, 0x4e, 0xef, 0x43, 0x26, 0x9f,
    0x59, 0x00, 0x38, 0x4c, 0x79, 0x16, 0xce, 0x6a,
    0xac, 0x91, 0x7e, 0xdb, 0xce, 0x67, 0x8c, 0x31,
    0x32, 0x59, 0xc9, 0x65, 0x83, 0x7a, 0xb2, 0xee,
    0x79, 0x5a, 0x76, 0xe5, 0x50, 0x1a, 0x3a, 0xee,
    0x64, 0x38, 0x0a, 0xf1, 0x11, 0x43, 0xa7, 0x47,
    0xca, 0xfe, 0xad, 0xa3, 0x98, 0x27, 0x51, 0xdc,
    0x28, 0xee, 0xe0, 0xfc, 0x4e, 0xb7, 0x3d, 0x1d,
    0xe9, 0x0e, 0x17, 0xd4, 0xe6, 0xb3, 0xa3, 0x70,
    0x15, 0xae, 0x6a, 0x0c, 0x5a, 0xda, 0x12, 0xbf,
    0x05, 0x61, 0x2d, 0xfd, 0x08, 0x52, 0x2a, 0x20,
    0x84, 0x1a, 0xf1, 0xa9, 0x34, 0x9b, 0x3b, 0x48,
    0x4f, 0x5f, 0x98, 0x0e, 0x4c, 0x73, 0xad, 0xae,
    0x6f, 0x71, 0xd1, 0x62, 0x21, 0xa9, 0xf3, 0x47,
    0x9b, 0xa8, 0x39, 0x9e, 0x7c, 0xe5, 0x37, 0x5d,
    0x61, 0xa6, 0x35, 0x95, 0x45, 0x84, 0xfa, 0x78,
    0xb3, 0xa0, 0x56, 0xc9, 0x87, 0xa2, 0xf7, 0xc5,
    0xb4, 0xf0, 0x51, 0xcf, 0xdd, 0xb2, 0x67, 0xf6,
    0xf1, 0xb4, 0x83, 0xdc, 0xf5, 0xd3, 0xbc, 0x7c,
    0xec, 0xd7, 0x2e, 0xc1, 0x68, 0x71, 0xe6, 0xe8,
    0x37, 0x21, 0x1b, 0xc3, 0x03, 0x35, 0xb5, 0x6a,
    0xd4, 0x24, 0xfe, 0xe0, 0x37, 0xf8, 0xa2, 0xb0,
    0x11, 0x2f, 0x63, 0x59, 0x47, 0x2b, 0xd2, 0x62,
    0x38, 0x7b, 0xfa, 0x4e, 0x75, 0xa4, 0x98, 0x68,
    0x9a, 0x2b, 0x26, 0xae, 0x30, 0x91, 0x55, 0xa8,
    0x7a, 0xe4, 0x14, 0x02, 0xbf, 0x49, 0xc7, 0x51,
    0x5c, 0xbe, 0xb6, 0xb2, 0xf8, 0xbf, 0xfa, 0x37,
    0x84, 0xff, 0xcf, 0x61, 0x86, 0x1e, 0x44, 0xde,
    0x7d, 0x41, 0xff, 0x7a, 0x87, 0x51, 0x58, 0x3c,
    0x14, 0x50, 0xf2, 0xf8, 0xc7, 0x18, 0x6f, 0x3c,
    0x6c, 0xe6, 0x3e, 0x22, 0xe2, 0xde, 0xed, 0xbf,
    0xcd, 0x81, 0xc3, 0xd2, 0xe1, 0x88, 0x66, 0xb2,
    0x5d, 0x93, 0x0c, 0x5e, 0xcb, 0x68, 0x94, 0x5c,
    0x10, 0xa8, 0xd1, 0x77, 0xe6, 0x2c, 0x94, 0x0a,
    0xd1, 0x79, 0x04, 0x1f, 0xf9, 0xd6, 0xc1, 0x83,
    0xe5, 0x34, 0x20, 0x58, 0x7d, 0x98, 0x35, 0xfd,
    0xa8, 0xbd, 0xab, 0x69, 0xe8, 0x7d, 0x9c, 0x3b,
    0xea, 0x26, 0xb4, 0xeb, 0x90, 0xe4, 0xa5, 0xa7,
    0x4f, 0xbd, 0x29, 0x2c, 0x67, 0xb7, 0xf9, 0x61,
    0x22, 0xde, 0x01, 0x9d, 0x41, 0x6a, 0x4c, 0xfb,
    0x9e, 0xf4, 0xd4, 0xf0, 0xf0, 0x99, 0xb5, 0xd8,
    0xf2, 0xfa, 0x5c, 0xe8, 0xfb, 0x9c, 0x03, 0x35,
    0xa2, 0x68, 0xde, 0x23, 0x0e, 0xcc, 0x8d, 0x5f,
    0xbc, 0xa7, 0xc5, 0xac, 0x56, 0x87, 0xd3, 0xb4,
    0xd3, 0xc4, 0x66, 0xd0, 0x95, 0x61, 0x09, 0x2a,
    0xca, 0x40, 0x79, 0xd7, 0x3f, 0x59, 0x9c, 0xb7,
    0x22, 0xf7, 0xd6, 0x23, 0x92, 0x33, 0x8d, 0xc1,
};

const rt_uint8_t rsa4096_sign_in[] =
{
    0x3c, 0x0e, 0xd8, 0x9e, 0x74, 0x1d, 0x04, 0x4c,
    0xa1, 0x44, 0xf4, 0x82, 0x62, 0xf6, 0xfd, 0xca,
    0x8b, 0x51, 0x9e, 0xb3, 0x93, 0xe8, 0xfa, 0x26,
    0xaf, 0x19, 0xe4, 0x78, 0x15, 0x9b, 0x9e, 0x25,
    0x8d, 0xe6, 0xf9, 0xcb, 0x8e, 0xe0, 0x6c, 0xae,
    0xae, 0x59, 0xa3, 0x72, 0xec, 0xbc, 0xc3, 0x61,
    0x89, 0x75, 0xd2, 0x1b, 0xed, 0xa0, 0x61, 0x50,
    0x0c, 0x14, 0x66, 0xeb, 0x84, 0x9b, 0x66, 0x9a,
    0x22, 0x46, 0x24, 0x65, 0xc7, 0xd2, 0x42, 0x37,
    0x4e, 0x46, 0x95, 0x9d, 0xb4, 0x0f, 0x21, 0x1f,
    0xc2, 0x79, 0xab, 0x99, 0x7d, 0xc1, 0x2b, 0x93,
    0xba, 0xf9, 0xb1, 0xd8, 0x28, 0xc7, 0x5c, 0x79,
    0x59, 0x2e, 0x5b, 0x85, 0xe6, 0x26, 0xc9, 0xf0,
    0xd0, 0x20, 0x11, 0xd6, 0x09, 0xb8, 0xa0, 0x2b,
    0xec, 0xc8, 0x3a, 0x15, 0xb6, 0xbd, 0xa3, 0xd7,
    0x32, 0x0c, 0x6c, 0xe2, 0xce, 0x1c, 0x5c, 0x8c,
    0xd2, 0xb9, 0x27, 0xb2, 0xb3, 0x74, 0x4d, 0x4e,
    0xca, 0x85, 0xd7, 0x6e, 0x18, 0xcf, 0xd0, 0xc3,
    0xfe, 0xcd, 0xd5, 0x0a, 0x8c, 0x18, 0x11, 0x61,
    0x9b, 0xbe, 0x55, 0x3c, 0xc0, 0xdd, 0xe8, 0x4f,
    0x60, 0x40, 0x0a, 0x2f, 0x1e, 0x54, 0xf8, 0xaf,
    0x7d, 0xd0, 0xde, 0x88, 0xd5, 0xe0, 0x57, 0x92,
    0xa6, 0xa3, 0x8d, 0xff, 0xb6, 0x22, 0xe0, 0xb4,
    0x1f, 0x36, 0x50, 0x9b, 0x66, 0xde, 0x0a, 0x7b,
    0x31, 0x9d, 0x85, 0x49, 0x4d, 0xb1, 0x6b, 0xe1,
    0x28, 0x55, 0x15, 0x0a, 0x7a, 0x48, 0x6a, 0xd7,
    0x40, 0xc2, 0xbc, 0x32, 0xe6, 0x64, 0x56, 0x58,
    0x95, 0x52, 0x83, 0xed, 0x03, 0x6a, 0x57, 0x5c,
    0x5e, 0xe2, 0x7a, 0xe4, 0x00, 0xb2, 0xcc, 0xc6,
    0xc4, 0xbd, 0x36, 0x21, 0xad, 0xd0, 0xa0, 0x39,
    0xa3, 0xd8, 0x13, 0x05, 0xa5, 0xc3, 0xdf, 0x2f,
    0x71, 0xbb, 0xc1, 0x4d, 0x2d, 0xdc, 0xba, 0xa5,
    0x0d, 0xe2, 0x25, 0xe4, 0x61, 0x7a, 0x86, 0x65,
    0x8a, 0xe8, 0x24, 0x6d, 0x9c, 0x54, 0x95, 0x25,
    0x4d, 0x8f, 0x3b, 0xc0, 0xb3, 0x3a, 0x57, 0x90,
    0x21, 0x4e, 0xd3, 0xf0, 0x3e, 0xb4, 0x54, 0x4d,
    0xf4, 0x8e, 0xa0, 0xa0, 0xf6, 0x19, 0xdb, 0x14,
    0x74, 0x7d, 0x08, 0xa5, 0x02, 0xc5, 0x37, 0x57,
    0xcb, 0x8f, 0x34, 0x24, 0xde, 0x00, 0x49, 0xf9,
    0x4c, 0xa8, 0x91, 0x3c, 0x77, 0x07, 0xa4, 0xa5,
    0xf2, 0xea, 0x99, 0x90, 0xf9, 0xf2, 0xfb, 0x79,
    0xb1, 0xb5, 0xcd, 0x0c, 0xba, 0x72, 0x9e, 0x24,
    0xb7, 0xed, 0x66, 0x98, 0x29, 0x33, 0xd3, 0xb7,
    0x6c, 0xbb, 0xf9, 0x25, 0x0a, 0x6c, 0x77, 0x3e,
    0x8e, 0xf2, 0x24, 0xc2, 0x25, 0xca, 0x59, 0xd7,
    0x24, 0x73, 0x99, 0x1c, 0xf6, 0x8d, 0x41, 0x98,
    0xb1, 0xcd, 0x36, 0x6a, 0xd9, 0xa5, 0xda, 0xc1,
    0x0c, 0x6d, 0x11, 0x84, 0xba, 0xe7, 0xad, 0xef,
    0x94, 0x1a, 0x33, 0xde, 0x5f, 0xa0, 0x8d, 0xe4,
    0x5e, 0xc8, 0x8c, 0x46, 0x74, 0xf3, 0x56, 0x8a,
    0x82, 0x02, 0x90, 0x3e, 0x16, 0x70, 0x3d, 0xd6,
    0x59, 0x35, 0x55, 0xbb, 0x5e, 0x93, 0xd7, 0xdb,
    0x3c, 0xe0, 0xb4, 0x80, 0x77, 0xc0, 0x87, 0x33,
    0xf8, 0x18, 0xc4, 0x16, 0x8f, 0xe7, 0x3e, 0x06,
    0xb2, 0xf7, 0x12, 0xf7, 0x15, 0xa5, 0xc4, 0x58,
    0x98, 0x32, 0xa3, 0x1e, 0xad, 0x9a, 0x48, 0xd9,
    0x2a, 0x0b, 0x65, 0xba, 0xdf, 0x6f, 0xc0, 0x9a,
    0x76, 0xd6, 0xb4, 0x04, 0x2b, 0xfb, 0xab, 0x38,
    0xc0, 0xf4, 0x30, 0x2a, 0x2f, 0xd7, 0xc7, 0x6e,
    0xe2, 0xa6, 0x4d, 0xe8, 0x54, 0x03, 0xe7, 0xa0,
    0x80, 0x09, 0xec, 0x28, 0x11, 0x43, 0x91, 0x42,
    0x68, 0x01, 0x55, 0x99, 0x58, 0x7c, 0xfb, 0x7e,
    0x50, 0x3f, 0xf8, 0xd0, 0x37, 0xee, 0xa0, 0x71,
    0x4c, 0x27, 0xcd, 0x81, 0x26, 0x7d, 0x70, 0x21,
};

const rt_uint8_t rsa4096_sign_out[] =
{
    0x19, 0xf8, 0x4d, 0x0b, 0xa8, 0xd5, 0x83, 0x4c,
    0x66, 0x26, 0x57, 0x2f, 0x01, 0x4d, 0x0e, 0xe9,
    0x13, 0x7f, 0x3f, 0xe7, 0xad, 0x5e, 0x30, 0x2d,
    0x09, 0x63, 0x3e, 0x5e, 0x8d, 0xc8, 0xca, 0x2d,
    0x7d, 0x93, 0x5a, 0x78, 0x1a, 0x7e, 0xe3, 0x10,
    0x6d, 0xf2, 0xc3, 0x93, 0x5e, 0xa5, 0xf5, 0x44,
    0x5f, 0xa1, 0x59, 0xc8, 0xb9, 0xac, 0x69, 0x96,
    0xa7, 0x7c, 0x29, 0x8d, 0x6a, 0x2d, 0x1a, 0x68,
    0x5f, 0x90, 0x94, 0x16, 0x27, 0xd7, 0x58, 0x5b,
    0xf7, 0x43, 0x35, 0x02, 0xa8, 0x22, 0xa2, 0x73,
    0x1c, 0x0b, 0xd5, 0x24, 0xd4, 0x5f, 0x2e, 0x51,
    0xbd, 0x03, 0x0b, 0x70, 0x21, 0x86, 0x50, 0x75,
    0x4c, 0xf9, 0xe1, 0xac, 0x72, 0x8b, 0x29, 0xcc,
    0xed, 0x30, 0x2f, 0x4d, 0x80, 0xbb, 0x6b, 0x95,
    0x85, 0xab, 0x54, 0x62, 0xab, 0x29, 0x24, 0xe9,
    0x7d, 0xde, 0xe1, 0xa9, 0xfc, 0x9e, 0x49, 0x50,
    0xbb, 0x5b, 0xf2, 0x41, 0xad, 0x5a, 0xce, 0x89,
    0x51, 0xe2, 0x62, 0x16, 0xc1, 0x21, 0x50, 0xf1,
    0xf7, 0x49, 0x25, 0x97, 0x52, 0x2a, 0xef, 0x4b,
    0x21, 0x42, 0xdd, 0x42, 0xdb, 0xae, 0x64, 0xed,
    0x32, 0x39, 0x4a, 0x10, 0xc6, 0xed, 0x9b, 0x96,
    0xf4, 0x2c, 0xde, 0x44, 0x1a, 0x06, 0xc7, 0xcc,
    0xa6, 0xd8, 0xb5, 0x77, 0x25, 0x1f, 0x49, 0xce,
    0x25, 0x60, 0x59, 0x99, 0x6e, 0x2e, 0x48, 0x6b,
    0x23, 0xe0, 0xd8, 0xbb, 0xcb, 0x39, 0x19, 0xcd,
    0x2f, 0x3e, 0x8a, 0x5b, 0xa4, 0xc7, 0x85, 0xf8,
    0x97, 0x4b, 0xe3, 0x86, 0x26, 0x8c, 0x89, 0xaa,
    0xc8, 0x12, 0xa6, 0x50, 0x82, 0xbe, 0xdc, 0xc2,
    0x89, 0xee, 0xcf, 0x9c, 0x6c, 0x1a, 0x2e, 0x69,
    0xf2, 0xa1, 0x63, 0x1a, 0x47, 0x0d, 0xda, 0x01,
    0x2f, 0x37, 0x7a, 0xec, 0x94, 0x97, 0x2d, 0xcd,
    0x50, 0x39, 0xb3, 0x43, 0xf8, 0xd9, 0xd6, 0x0c,
    0x53, 0xd8, 0xdc, 0x1f, 0xd9, 0x21, 0x6a, 0x73,
    0x79, 0xad, 0xe6, 0x40, 0xf8, 0x53, 0x5e, 0xa5,
    0x71, 0x77, 0x25, 0x5b, 0x64, 0xbe, 0xa7, 0x51,
    0xc3, 0x17, 0xba, 0x21, 0x89, 0xa7, 0xad, 0x51,
    0x41, 0x4e, 0x79, 0x5b, 0x25, 0xf7, 0xfa, 0x3c,
    0x16, 0x47, 0x1f, 0xb3, 0x63, 0xdf, 0x9d, 0x0c,
    0x6c, 0x07, 0x45, 0x82, 0x38, 0x5f, 0xd7, 0x6a,
    0x75, 0xba, 0x48, 0x33, 0xeb, 0x78, 0xc6, 0xaa,
    0xe2, 0x32, 0x98, 0x6c, 0x93, 0x22, 0x43, 0x68,
    0xe2, 0x8a, 0xc4, 0xe7, 0xce, 0x73, 0x47, 0xdf,
    0x0c, 0x58, 0xe0, 0x69, 0x33, 0xe2, 0xe4, 0x82,
    0x11, 0x58, 0x20, 0x17, 0xb6, 0x02, 0x2f, 0xb0,
    0x33, 0x77, 0xd9, 0x82, 0x19, 0x27, 0xbd, 0x7b,
    0xd9, 0x42, 0x31, 0xc7, 0xbe, 0x53, 0x6c, 0xc6,
    0x2a, 0x62, 0xc8, 0xe4, 0x15, 0xe9, 0x24, 0xa4,
    0xd9, 0x23, 0x32, 0x89, 0x46, 0xa5, 0x57, 0x5a,
    0x84, 0xd8, 0x07, 0x98, 0xab, 0xe1, 0xd3, 0x7e,
    0x17, 0x8c, 0x8e, 0x86, 0xd9, 0x7a, 0x8c, 0x58,
    0x02, 0x7c, 0x7d, 0xe2, 0x71, 0x0a, 0x7b, 0x86,
    0x2b, 0x92, 0x6e, 0xf1, 0x95, 0xdd, 0x9a, 0xcb,
    0xa2, 0xa3, 0x57, 0x81, 0xed, 0xd0, 0x18, 0x9f,
    0x25, 0xfe, 0xc3, 0xd3, 0x8c, 0xbf, 0xc5, 0xd5,
    0x32, 0x78, 0xb1, 0xe6, 0x9e, 0x10, 0xaf, 0xea,
    0x25, 0xb6, 0x94, 0x6b, 0x29, 0xdc, 0x1a, 0x4f,
    0xaf, 0x9d, 0x11, 0x33, 0x88, 0x03, 0xd0, 0x34,
    0xc3, 0xcf, 0x48, 0x7c, 0x67, 0x37, 0x02, 0xdc,
    0x3d, 0x9b, 0x3e, 0x6b, 0xb1, 0x96, 0x9b, 0x00,
    0x09, 0xd8, 0xec, 0x1c, 0x16, 0x7e, 0x23, 0x35,
    0x29, 0xc6, 0xf3, 0x5e, 0x15, 0xd1, 0x82, 0x60,
    0xad, 0x3e, 0x5d, 0x9b, 0x83, 0xf1, 0x17, 0xeb,
    0xd8, 0x76, 0x4d, 0x8f, 0x15, 0x0f, 0xcd, 0x5d,
    0xd9, 0x68, 0xd3, 0x8e, 0xbd, 0x29, 0x8d, 0x10,
};

static void hw_bignum_sample()
{
    struct hw_bignum_mpi n, e, d, sign_in, sign_out;
    struct hw_bignum_mpi tmp_sign_in, tmp_sign_out;
    uint8_t data[512];
    int data_len = 0;
    rt_tick_t start, end1, end2;

    rt_kprintf("======================== Bignum Test start ========================\n");

    rt_hwcrypto_bignum_init(&n);
    rt_hwcrypto_bignum_init(&e);
    rt_hwcrypto_bignum_init(&d);
    rt_hwcrypto_bignum_init(&sign_in);
    rt_hwcrypto_bignum_init(&sign_out);
    rt_hwcrypto_bignum_init(&tmp_sign_in);
    rt_hwcrypto_bignum_init(&tmp_sign_out);

    rt_kprintf("\n============ ExptMod Test Start ============\n");

    rt_hwcrypto_bignum_import_bin(&n, (rt_uint8_t *)rsa4096_n, sizeof(rsa4096_n));
    rt_hwcrypto_bignum_import_bin(&e, (rt_uint8_t *)rsa4096_e, sizeof(rsa4096_e));
    rt_hwcrypto_bignum_import_bin(&d, (rt_uint8_t *)rsa4096_d, sizeof(rsa4096_d));
    rt_hwcrypto_bignum_import_bin(&sign_in, (rt_uint8_t *)rsa4096_sign_in, sizeof(rsa4096_sign_in));
    rt_hwcrypto_bignum_import_bin(&sign_out, (rt_uint8_t *)rsa4096_sign_out, sizeof(rsa4096_sign_out));

    start = rt_tick_get_millisecond();

    /* tmp_sign_out = sign_in ^ d (mod n) */
    rt_hwcrypto_bignum_exptmod(&tmp_sign_out, &sign_in, &d, &n);

    end1 = rt_tick_get_millisecond();

    /* tmp_sign_in = sign_out ^ e (mod n) */
    rt_hwcrypto_bignum_exptmod(&tmp_sign_in, &sign_out, &e, &n);

    end2 = rt_tick_get_millisecond();

    memset(data, 0x00, sizeof(data));
    data_len = rt_hwcrypto_bignum_export_bin(&tmp_sign_out, data, sizeof(data));
    if (data_len != sizeof(rsa4096_sign_out) || rt_memcmp(data, rsa4096_sign_out, data_len) != 0)
    {
        rt_kprintf("Except %s result:\n", "sign");
        dump_hex(rsa4096_sign_out, sizeof(rsa4096_sign_out));
        rt_kprintf("Actual %s result:\n", "verify");
        dump_hex(data, data_len);
        rt_kprintf("Test exptmod sign fail, result not match!\n");
    }
    else
    {
        rt_kprintf("exptmod sign   Test success, RSA4096 cost %5ums!\n", end1 - start);
    }

    memset(data, 0x00, sizeof(data));
    data_len = rt_hwcrypto_bignum_export_bin(&tmp_sign_in, data, sizeof(data));
    if (data_len != sizeof(rsa4096_sign_in) || rt_memcmp(data, rsa4096_sign_in, data_len) != 0)
    {
        rt_kprintf("Except %s result:\n", "verify");
        dump_hex(rsa4096_sign_in, sizeof(rsa4096_sign_in));
        rt_kprintf("Actual %s result:\n", "verify");
        dump_hex(data, data_len);
        rt_kprintf("Test exptmod verify fail, result not match!\n");
    }
    else
    {
        rt_kprintf("exptmod verify Test success, RSA4096 cost %5ums!\n", end2 - end1);
    }

    rt_kprintf("============ ExptMod Test Over ============\n");

    rt_hwcrypto_bignum_free(&n);
    rt_hwcrypto_bignum_free(&e);
    rt_hwcrypto_bignum_free(&d);
    rt_hwcrypto_bignum_free(&sign_in);
    rt_hwcrypto_bignum_free(&sign_out);
    rt_hwcrypto_bignum_free(&tmp_sign_in);
    rt_hwcrypto_bignum_free(&tmp_sign_out);
    rt_kprintf("======================== Bignum Test over! ========================\n");
}
#endif

static int crypto(int argc, char **argv)
{
    int result = RT_EOK;
    static rt_device_t device = RT_NULL;
    char *result_str;

    if (argc > 1)
    {
        if (!strcmp(argv[1], "probe"))
        {
            if (argc == 3)
            {
                char *dev_name = argv[2];
                device = rt_device_find(dev_name);
                result_str = (device == RT_NULL) ? "failure" : "success";
                rt_kprintf("probe %s %s \n", argv[2], result_str);
            }
            else
            {
                rt_kprintf("crypto probe <crypto_name>   - probe crypto by name\n");
            }
        }
        else
        {
            if (device == RT_NULL)
            {
                rt_kprintf("Please using 'crypto probe <crypto_name>' first\n");
                return -RT_ERROR;
            }
            if (!strcmp(argv[1], "rng"))
            {
#if defined (RT_HWCRYPTO_USING_RNG)
                if (argc == 3)
                {
                    result = hw_rng_sample(atoi(argv[2]));
                    if (result != RT_EOK)
                    {
                        rt_kprintf("please input a  legal number, not <%d>\n", atoi(argv[2]));
                    }
                }
                else
                {
                    rt_kprintf("rng <number>        - generate <number> digital\n");
                }

#else
                rt_kprintf("please enable RNG first!\n");
#endif
            }
            else if (!strcmp(argv[1], "hash"))
            {
                if (argc == 3)
                {
                    hw_hash_sample();
                    hw_multi_hash_sample();
                    hw_hash_perf_sample();
                }
                else
                {
                    rt_kprintf("crypto hash sample          - hash use sample\n");
                }
            }
            else if (!strcmp(argv[1], "cryp"))
            {
                if (argc == 3)
                {
                    hw_cryp_sample();
                    hw_cryp_perf_sample();
                }
                else
                {
                    rt_kprintf("crypto cryp sample          - encrypt and decrypt data sample\n");
                }
            }
#if defined(RT_HWCRYPTO_USING_BIGNUM)
            else if (!strcmp(argv[1], "bignum"))
            {
                if (argc == 3)
                {
                    hw_bignum_sample();
                }
                else
                {
                    rt_kprintf("crypto bignum sample        - bignum expmod data\n");
                }
            }
#endif
            else
            {
                rt_kprintf("Unknown command. Please enter 'crypto' for help\n");
            }
        }
    }
    else
    {
        rt_kprintf("Usage: \n");
        rt_kprintf("crypto probe <crypto_name>                  - probe crypto by name\n");
#if defined (BSP_USING_TRNG)
        rt_kprintf("crypto rng number                           - generate numbers digital\n");
#endif
#if defined (BSP_USING_CRYPTO)
        rt_kprintf("crypto hash sample                          - hash use sample\n");
        rt_kprintf("crypto cryp sample                          - encrypt and decrypt data\n");
        rt_kprintf("crypto bignum sample                        - bignum expmod data\n");
#endif
        result = -RT_ERROR;
    }

    return result;
}

#ifdef RT_USING_FINSH
#include <finsh.h>
MSH_CMD_EXPORT(crypto, crypto function);
#endif

#endif

